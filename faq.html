<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>纯钧</title><meta name="description" content="纯钧Chunjun"/><link rel="shortcut icon" href="/favicon.ico"/><link rel="preload" as="image" imageSrcSet="https://dtstack.github.io/chunjun/logo-dark.svg?auto=format&amp;fit=max&amp;w=48 1x, https://dtstack.github.io/chunjun/logo-dark.svg?auto=format&amp;fit=max&amp;w=96 2x"/><link rel="preload" as="image" imageSrcSet="https://dtstack.github.io/chunjun/assets/img/dt.jpg?auto=format&amp;fit=max&amp;w=256 1x, https://dtstack.github.io/chunjun/assets/img/dt.jpg?auto=format&amp;fit=max&amp;w=384 2x"/><meta name="next-head-count" content="7"/><link rel="preload" href="/chunjun/_next/static/css/af2e203d093fe9d3.css" as="style"/><link rel="stylesheet" href="/chunjun/_next/static/css/af2e203d093fe9d3.css" data-n-g=""/><link rel="preload" href="/chunjun/_next/static/css/7f6bd37aab40623f.css" as="style"/><link rel="stylesheet" href="/chunjun/_next/static/css/7f6bd37aab40623f.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/chunjun/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/chunjun/_next/static/chunks/webpack-2e848446474e7607.js" defer=""></script><script src="/chunjun/_next/static/chunks/framework-715a76d8b0695da7.js" defer=""></script><script src="/chunjun/_next/static/chunks/main-81f142babc1febde.js" defer=""></script><script src="/chunjun/_next/static/chunks/pages/_app-cd0ee6706804819d.js" defer=""></script><script src="/chunjun/_next/static/chunks/593-1735b7ed6c299e84.js" defer=""></script><script src="/chunjun/_next/static/chunks/783-3a46b6d46094f0da.js" defer=""></script><script src="/chunjun/_next/static/chunks/37-779e7f2091f4cf60.js" defer=""></script><script src="/chunjun/_next/static/chunks/pages/faq-3dc77b4986d886cc.js" defer=""></script><script src="/chunjun/_next/static/jacWqOyTtEWAregOgv7R0/_buildManifest.js" defer=""></script><script src="/chunjun/_next/static/jacWqOyTtEWAregOgv7R0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><style data-emotion="css-global zl4edr">html{font-family:sans-serif;line-height:1.15;-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;-ms-text-size-adjust:100%;text-size-adjust:100%;}body{margin:0;}article,aside,footer,header,nav,section,figcaption,figure,main{display:block;}h1{font-size:2em;}hr{box-sizing:content-box;height:0;overflow:visible;}pre{font-family:monospace,monospace;font-size:1em;}a{background:transparent;text-decoration-skip:objects;}a:active,a:hover{outline-width:0;}abbr[title]{border-bottom:none;-webkit-text-decoration:underline;text-decoration:underline;}b,strong{font-weight:bolder;}code,kbp,samp{font-family:monospace,monospace;font-size:1em;}dfn{font-style:italic;}mark{background-color:#ff0;color:#000;}small{font-size:80%;}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline;}sup{top:-0.5em;}sub{bottom:-0.25em;}audio,video{display:inline-block;}audio:not([controls]){display:none;height:0;}img{border-style:none;vertical-align:middle;}svg:not(:root){overflow:hidden;}button,input,optgroup,select,textarea{font-family:sans-serif;font-size:100%;line-height:1.15;margin:0;}button,input{overflow:visible;}button,select{text-transform:none;}button,[type=reset],[type=submit]{-webkit-appearance:button;}button::-moz-focus-inner,[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner{border-style:none;padding:0;}button:-moz-focusring,[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring{outline:1px dotted ButtonText;}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal;}progress{display:inline-block;vertical-align:baseline;}textarea{overflow:auto;}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0;}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto;}[type=search]{-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none;appearance:none;}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none;-moz-appearance:none;-ms-appearance:none;appearance:none;}::-webkit-file-upload-button{-webkit-appearance:button;-moz-appearance:button;-ms-appearance:button;appearance:button;font:inherit;}details,menu{display:block;}summary{display:-webkit-box;display:-webkit-list-item;display:-ms-list-itembox;display:list-item;}canvas{display:inline-block;}template{display:none;}[hidden]{display:none;}</style><style data-emotion="css-global o0vtrk">*,*::before,*::after{box-sizing:border-box;}body{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;background-color:#1A1B1E;color:#C1C2C5;line-height:1.55;font-size:16px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}</style><div class="mantine-AppShell-root mantine-osix87"><header class="mantine-Header-root flex items-center justify-between sticky shadow-md bg--gray-50 2xl:px-[22vw] mantine-l7uzwz"><button class="mantine-UnstyledButton-root mantine-Burger-root md:hidden inline-block mantine-1qunjfw" type="button"><div class="mantine-efwleb mantine-Burger-burger"></div></button><div class="h-full flex items-center flex-1 cursor-pointer"><div class="flex h-full items-center md:justify-start justify-center md:w-auto w-full"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2748%27%20height=%2748%27/%3e"/></span><img alt="logo of chunjun" srcSet="https://dtstack.github.io/chunjun/logo-dark.svg?auto=format&amp;fit=max&amp;w=48 1x, https://dtstack.github.io/chunjun/logo-dark.svg?auto=format&amp;fit=max&amp;w=96 2x" src="https://dtstack.github.io/chunjun/logo-dark.svg?auto=format&amp;fit=max&amp;w=96" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/></span><div class="mantine-Text-root text-xl capitalize flex items-center font-nunito select-none mantine-ljqvxq">Chunjun</div></div><div class="h-full justify-center flex-1 md:flex hidden items-center"><a class="font-nunito inline-block md:w-[72px] text-center" href="/chunjun">首页</a><a class="font-nunito inline-block md:w-[72px] text-center" href="/chunjun/documents/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">文档</a><a href="https://github.com/DTStack/chunjun/releases" class="font-raleway inline-block md:w-[72px] text-center" target="blank">下载</a><a class="font-nunito inline-block md:w-[72px] text-center" href="/chunjun/faq">指南</a><span class="flex items-center md:w-[72px] justify-center text-center" aria-haspopup="menu" aria-expanded="false" aria-controls="mantine-Rmiq6-dropdown" id="mantine-Rmiq6-target">案例<svg xmlns="http://www.w3.org/2000/svg" class="ml-1" width="16" height="16" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><polyline points="6 9 12 15 18 9"></polyline></svg></span><a class="font-nunito inline-block md:w-[72px] text-center" href="/chunjun/contributor">贡献者</a></div></div><div class="h-full flex items-center space-x-4 pr-[9px]"><div class="mantine-SegmentedControl-root mantine-1lhn4s5"><div class="__mantine-ref-control mantine-SegmentedControl-control mantine-SegmentedControl-controlActive mantine-h4is5c"><input class="mantine-1nwij4 mantine-SegmentedControl-input" type="radio" name="mantine-R1qq6" id="mantine-R1qq6-zh-Hans" checked="" value="zh-Hans"/><label class="__mantine-ref-label mantine-SegmentedControl-label mantine-SegmentedControl-labelActive mantine-1kbbj7g" for="mantine-R1qq6-zh-Hans">简体中文</label></div><div class="__mantine-ref-control mantine-y33k1r mantine-SegmentedControl-control"><input class="mantine-1nwij4 mantine-SegmentedControl-input" type="radio" name="mantine-R1qq6" id="mantine-R1qq6-en" value="en"/><label class="__mantine-ref-label mantine-1iq8fgn mantine-SegmentedControl-label" for="mantine-R1qq6-en">English</label></div></div><button class="mantine-UnstyledButton-root mantine-ActionIcon-root mantine-1pknu1d" type="button"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon" width="24" height="24" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path></svg></button></div><style data-emotion="css-global bfdpot">:root{--mantine-header-height:64px;}</style></header><div class="mantine-ibbm6b mantine-AppShell-body"><main class="mantine-1iojl7v mantine-AppShell-main"><div class="md:w-4/5 2xl:w-[55vw] w-full mx-auto py-8"><div class="mantine-Text-root px-4 md:py-12 md:text-3xl text-base capitalize md:mb-12 mb-8 font-bold mantine-ljqvxq" data-aos="fade-zoom-in">hi, 你好, 这里是指南,你可以通过阅读我们的指南来了解<span class="underline decoration-purple-500 decoration-wavy md:decoration-4 decoration-2">纯钧</span>，祝你<span class="underline decoration-green-500 decoration-wavy md:decoration-4 decoration-2">玩得开心!</span></div><div id="top" class="h-8"></div><div class="mantine-Tabs-root mb-8 mantine-15po0m8"><div class="mantine-Tabs-tabsList mantine-16srswh" role="tablist" aria-orientation="horizontal"><button class="mantine-UnstyledButton-root mantine-Tabs-tab mantine-pknhpx" type="button" data-active="true" role="tab" id="mantine-Rdda6-tab-pr" aria-selected="true" tabindex="0" aria-controls="mantine-Rdda6-panel-pr"><div class="mantine-14swocp mantine-Tabs-tabIcon"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="14" height="14" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"></path></svg></div><div class="mantine-1s8spa1 mantine-Tabs-tabLabel">如何提交一个优秀的PR</div></button><button class="mantine-UnstyledButton-root mantine-Tabs-tab mantine-pknhpx" type="button" role="tab" id="mantine-Rdda6-tab-plugin" aria-selected="false" tabindex="-1" aria-controls="mantine-Rdda6-panel-plugin"><div class="mantine-14swocp mantine-Tabs-tabIcon"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-affiliate" width="14" height="14" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M5.931 6.936l1.275 4.249m5.607 5.609l4.251 1.275"></path><path d="M11.683 12.317l5.759 -5.759"></path><circle cx="5.5" cy="5.5" r="1.5"></circle><circle cx="18.5" cy="5.5" r="1.5"></circle><circle cx="18.5" cy="18.5" r="1.5"></circle><circle cx="8.5" cy="15.5" r="4.5"></circle></svg></div><div class="mantine-1s8spa1 mantine-Tabs-tabLabel">如何自定义插件</div></button></div><div class="mantine-Tabs-panel mantine-um9jxx" role="tabpanel" id="mantine-Rdda6-panel-pr" aria-labelledby="mantine-Rdda6-tab-pr"><blockquote class="mantine-Blockquote-root mantine-xssona"><div class="mantine-17do188 mantine-Blockquote-inner"><div class="mantine-1gsur4i mantine-Blockquote-icon"><svg width="20" height="20" viewBox="0 0 409.294 409.294" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 204.647v175.412h175.412V204.647H58.471c0-64.48 52.461-116.941 116.941-116.941V29.235C78.684 29.235 0 107.919 0 204.647zM409.294 87.706V29.235c-96.728 0-175.412 78.684-175.412 175.412v175.412h175.412V204.647H292.353c0-64.48 52.461-116.941 116.941-116.941z"></path></svg></div><div class="mantine-1nksqbd mantine-Blockquote-body"><div class="mantine-TypographyStylesProvider-root md:col-span-3 p-4 overflow-hidden mantine-1t1c6l3"><article class="article dark">
              <a id="如何提交一个优秀的pr" style='display: block; height: 35px;'></a>
              <h1>
                如何提交一个优秀的pr
              </h1>
            <p>在github上提交pr是参与ChunJun开源项目的一个重要途径，小伙伴们在使用中的一些功能上feature或者bug都可以向社区提交pr贡献代码，也可以根据已有的issue提供自己的解决方案。下面给大家带来提交一个优秀PR的步骤。</p>

              <a id="第一步：fork chunjun到自己的github仓库" style='display: block; height: 35px;'></a>
              <h2>
                第一步：fork chunjun到自己的github仓库
              </h2>
            <p><img src="/chunjun/doc/pr/pr1.png" alt="image"></p>
<p>点击fork后就可以在自己仓库中看到以你名字命名的chunjun项目了：</p>
<p><img src="/chunjun/doc/pr/pr2.png" alt="image"></p>

              <a id="第二步：clone chunjun到本地IDE" style='display: block; height: 35px;'></a>
              <h2>
                第二步：clone chunjun到本地IDE
              </h2>
            <p><img src="/chunjun/doc/pr/pr3.png" alt="image"></p>

              <a id="第三步：将DTStack/chunjun设置为本地仓库的远程分支upstream" style='display: block; height: 35px;'></a>
              <h2>
                第三步：将DTStack/chunjun设置为本地仓库的远程分支upstream
              </h2>
            <pre><code class="language-shell">$ cd chunjun
<span class="hljs-comment"># add upstream</span>
$ git remote add upstream https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/DTStack/</span>chunjun.git
<span class="hljs-comment"># 查看远程仓库设置</span>
$ git remote -v
origin  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/your_name/</span>chunjun.git (fetch)
origin  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/your_name/</span>chunjun.git (push)
upstream    https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/DTStack/</span>chunjun.git (fetch)
upstream    https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/DTStack/</span>chunjun.git (push)
</code></pre>

              <a id="第四步：提交代码" style='display: block; height: 35px;'></a>
              <h2>
                第四步：提交代码
              </h2>
            <p>任何一个提交都要基于最新的分支
<strong>切换分支</strong></p>
<pre><code class="language-shell"><span class="hljs-comment"># Fetch branches from upstream.</span>
<span class="hljs-variable">$ </span>git remote update upstream -p
<span class="hljs-comment"># Checkout a new branch.</span>
<span class="hljs-variable">$ </span>git checkout -b branch_name
<span class="hljs-comment"># Pull latest code into your own branch.</span>
<span class="hljs-variable">$ </span>git pull upstream <span class="hljs-symbol">master:</span>branch_name
</code></pre>
<p><strong>本地修改代码后，提交commit</strong></p>
<ul>
<li>commit message 规范：
[commit_type-#issue-id] [module] message</li>
<li>commit_type:<ul>
<li>feat：表示是一个新功能（feature)</li>
<li>hotfix：hotfix，修补bug</li>
<li>docs：改动、增加文档</li>
<li>opt：修改代码风格及opt imports这些，不改动原有执行的代码</li>
<li>test：增加测试</li>
</ul>
</li>
<li>eg:[hotfix-#12345][mysql] Fix mysql time type loses precision.</li>
</ul>
<p>注意：
（1）commit 需遵循规范，给维护者减少维护成本及工作量，对于不符合规范的commit，我们不与合并；
（2）对于解决同一个Issue的PR，只能存在一个commit message，如果出现多次提交的message，我们希望你能将commit message &#39;squash&#39; 成一个；
（3）message 尽量保持清晰简洁，但是也千万不要因为过度追求简洁导致描述不清楚，如果有必要，我们也不介意message过长，前提是，能够把解决方案、修复内容描述清楚；</p>
<pre><code class="language-shell"><span class="hljs-comment"># 提交commit前先进行代码格式化</span>
<span class="hljs-variable">$ </span>mvn <span class="hljs-symbol">spotless:</span>apply
<span class="hljs-variable">$ </span>git commit -a -m <span class="hljs-string">&quot;&lt;you_commit_message&gt;&quot;</span>
</code></pre>
<p><strong>rebase远程分支</strong></p>
<p>这一步很重要，因为我们仓库中的chunjun代码很有可能已经落后于社区，所以在 push commit前需要rebase，保证当前commit是基于社区最新的代码，很多小伙伴没有这一步导致提交的pr当中包含了其他人的commit</p>
<pre><code class="language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git fetch upstream</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">git rebase upstream/branch_name</span>
</code></pre>
<p>*rebase后有可能出现代码冲突，一般是由于多人编辑同一个文件引起的，只需要根据提示打开冲突文件对冲突部分进行修改，将提示的冲突文件的冲突都解决后，执行</p>
<pre><code class="language-shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">git add .</span>
<span class="hljs-meta prompt_">$ </span><span class="language-bash">git rebase --<span class="hljs-built_in">continue</span></span>
</code></pre>
<p>依此往复，直至屏幕出现类似rebase successful字样即可</p>
<p>*rebase之后代码可能无法正常推送，需要<code>git push -f</code> 强制推送，强制推送是一个有风险的操作，操作前请仔细检查以避免出现无关代码被强制覆盖的问题</p>
<p><strong>push到github仓库</strong></p>
<pre><code class="language-shell">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> branch_name
</code></pre>

              <a id="第五步：提交pr" style='display: block; height: 35px;'></a>
              <h2>
                第五步：提交pr
              </h2>
            <p>以笔者修复kafka写入过程中出现空指针问题为例，经过步骤四笔者已经把代码提交至笔者自己仓库的master分支</p>
<p><img src="/chunjun/doc/pr/pr4.png" alt="image"></p>
<p>进入chunjun仓库页面，点击Pull Request</p>
<p><img src="/chunjun/doc/pr/pr5.png" alt="image"></p>
<p><img src="/chunjun/doc/pr/pr6.png" alt="image"></p>
<p>选择head仓库和base仓库以及相应的分支</p>
<p><img src="/chunjun/doc/pr/pr7.png" alt="image"></p>
<p>填写pr信息，pr信息应该尽量概括清楚问题的前因后果，如果存在对应issue要附加issue地址，保证问题是可追溯的</p>
<p><img src="/chunjun/doc/pr/pr8.png" alt="image"></p>
<p><img src="/chunjun/doc/pr/pr9.png" alt="image"></p>
<p>PR提交成功后需要一段时间代码review，可以耐心等待一下项目维护者review后合入，或者在PR评论区艾特相关人员。</p>
</article></div><cite class="mantine-o8skp2 mantine-Blockquote-cite">– 如何提交一个优秀的PR</cite></div></div></blockquote></div><div class="mantine-Tabs-panel mantine-rpjjmj" role="tabpanel" id="mantine-Rdda6-panel-plugin" aria-labelledby="mantine-Rdda6-tab-plugin"><blockquote class="mantine-Blockquote-root mantine-xssona"><div class="mantine-17do188 mantine-Blockquote-inner"><div class="mantine-1gsur4i mantine-Blockquote-icon"><svg width="20" height="20" viewBox="0 0 409.294 409.294" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M0 204.647v175.412h175.412V204.647H58.471c0-64.48 52.461-116.941 116.941-116.941V29.235C78.684 29.235 0 107.919 0 204.647zM409.294 87.706V29.235c-96.728 0-175.412 78.684-175.412 175.412v175.412h175.412V204.647H292.353c0-64.48 52.461-116.941 116.941-116.941z"></path></svg></div><div class="mantine-1nksqbd mantine-Blockquote-body"><div class="mantine-TypographyStylesProvider-root md:col-span-3 p-4 overflow-hidden mantine-1t1c6l3"><article class="article dark">
              <a id="如何自定义插件" style='display: block; height: 35px;'></a>
              <h2>
                如何自定义插件
              </h2>
            <p>本文面向ChunJun插件开发人员，尝试通过一个开发者的角度尽可能全面地阐述一个ChunJun插件所经历的过程，同时消除开发者的困惑，快速上手插件开发。</p>
<p>从数据流的角度来看ChunJun，可以理解为不同数据源的数据流通过对应的ChunJun插件处理，变成符合ChunJun数据规范的数据流；脏数据的处理可以理解为脏水流通过污水处理厂，变成符合标准，可以使用的水流，而对不能处理的水流收集起来。</p>
<p>插件开发不需要关注任务具体如何调度，只需要关注关键问题：</p>
<ol>
<li>数据源本身读写数据的正确性；</li>
<li>如何合理且正确地使用框架；</li>
<li>配置文件的规范，每个插件都应有对应的配置文件；</li>
</ol>
<p>每个插件应当有以下目录：</p>
<ol>
<li>conf：存放插件配置类的包。</li>
<li>converter：存放插件数据类型转换规则类的包。</li>
<li>source：存放插件数据源读取逻辑有关类的包。</li>
<li>sink：存放插件数据源写入逻辑有关类的包。</li>
<li>table：存放插件数据源sql模式有关类的包。</li>
<li>util：存放插件工具类的包，chunjun已经封装了一些常用工具类在chunjun-core模块中，如果还需编写插件工具类的请放在该插件目录中的util包。</li>
</ol>

              <a id="一. Debug调试" style='display: block; height: 35px;'></a>
              <h3>
                一. Debug调试
              </h3>
            
              <a id="（1）本地调试" style='display: block; height: 35px;'></a>
              <h4>
                （1）本地调试
              </h4>
            <p>在chunjun-local-test模块中，官方已经写好了本地测试的LocalTest类，只需更改脚本文件路径，在代码处打上断点即可调试。</p>
<p><img src="/chunjun/doc/contribute/image-20220614171917692.png" alt="image-20220614171917692"></p>

              <a id="（2）远程调试" style='display: block; height: 35px;'></a>
              <h4>
                （2）远程调试
              </h4>
            <p>如果需要远程调试，那么需要在 flink-conf.yaml 中增加 Flink 的远程调试配置，然后在 idea 中配置”JVM Remote“，在代码块中打断点（这种方法还能调试 Flink 本身的代码）</p>
<pre><code class="language-shell">env<span class="hljs-selector-class">.java</span><span class="hljs-selector-class">.opts</span><span class="hljs-selector-class">.jobmanager</span>: -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=<span class="hljs-number">5005</span> 

env<span class="hljs-selector-class">.java</span><span class="hljs-selector-class">.opts</span><span class="hljs-selector-class">.taskmanager</span>: -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=<span class="hljs-number">5006</span>
</code></pre>
<p>只需要修改标记的这两个地方，如果是 HA 集群，需要根据日志修改<strong>怎么看日志，怎么修改，自行查资料</strong>。</p>
<p><img src="/chunjun/doc/contribute/image-20220614172338108.png" alt="image-20220614172338108"></p>
<p>至此，任务 idea 调试流程就这些内容。</p>

              <a id="二. sync(json)插件" style='display: block; height: 35px;'></a>
              <h3>
                二. sync(json)插件
              </h3>
            <p>以Stream插件为例：</p>

              <a id="(1) reader" style='display: block; height: 35px;'></a>
              <h4>
                (1) reader
              </h4>
            <p>插件数据源读取逻辑需要继承BaseRichInputFormat类，BaseRichInputFormat是具体的输入数据的操作，包括open、nextRecord、close，每个插件具体操作自己的数据，InputFormat公共内容都在BaseRichInputFormat，不要随意修改。</p>
<p>创建StreamInputFormat类继承BaseRichInputFormat类，重写其中的必要方法。</p>
<pre><code class="language-java"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">StreamInputFormat</span> <span class="hljs-selector-tag">extends</span> <span class="hljs-selector-tag">BaseRichInputFormat</span> {
    <span class="hljs-comment">//创建数据分片</span>
    <span class="hljs-variable">@Override</span>
    public InputSplit[] <span class="hljs-built_in">createInputSplitsInternal</span>(int minNumSplits) {......}
    <span class="hljs-comment">//打开数据连接</span>
    <span class="hljs-variable">@Override</span>
    public void <span class="hljs-built_in">openInternal</span>(InputSplit inputSplit) {......}
    <span class="hljs-comment">//读取一条数据</span>
     <span class="hljs-variable">@Override</span>
    public RowData <span class="hljs-built_in">nextRecordInternal</span>(RowData rowData) throws ReadRecordException {......}
    <span class="hljs-comment">//判断数据是否读取完毕</span>
    <span class="hljs-variable">@Override</span>
    public boolean <span class="hljs-built_in">reachedEnd</span>() {......}
    <span class="hljs-comment">//关闭数据连接</span>
    <span class="hljs-variable">@Override</span>
    protected void <span class="hljs-built_in">closeInternal</span>() {......}
}
</code></pre>
<p>StreamInputFormat类是通过StreamInputFormatBuilder类构建的。</p>
<pre><code class="language-java">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamInputFormatBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRichInputFormatBuilder&lt;StreamInputFormat&gt;</span>  </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StreamInputFormat</span> format;

    public <span class="hljs-type">StreamInputFormatBuilder</span>() {
        <span class="hljs-keyword">super</span>.format = format = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamInputFormat</span>();
    }
    <span class="hljs-comment">//检查inputformat配置</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> void checkFormat() {......}
}
</code></pre>
<p>创建StreamSourceFactory继承SourceFactory类</p>
<pre><code class="language-java">public <span class="hljs-keyword">class</span> StreamSourceFactory extends SourceFactory {
    <span class="hljs-keyword">private</span> final StreamConf streamConf;

    public <span class="hljs-constructor">StreamSourceFactory(SyncConf <span class="hljs-params">config</span>, StreamExecutionEnvironment <span class="hljs-params">env</span>)</span> {......}
    
    <span class="hljs-comment">//构建数据流读取对象</span>
    @Override
    public DataStream&lt;RowData&gt; create<span class="hljs-constructor">Source()</span> {
        StreamInputFormatBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StreamInputFormatBuilder()</span>;
        builder.set<span class="hljs-constructor">StreamConf(<span class="hljs-params">streamConf</span>)</span>;
        AbstractRowConverter rowConverter;
        <span class="hljs-keyword">if</span> (useAbstractBaseColumn) {
            rowConverter = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StreamColumnConverter(<span class="hljs-params">streamConf</span>)</span>;
        } <span class="hljs-keyword">else</span> {
            check<span class="hljs-constructor">Constant(<span class="hljs-params">streamConf</span>)</span>;
            final RowType rowType =
                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TableUtil</span>.</span></span>create<span class="hljs-constructor">RowType(<span class="hljs-params">streamConf</span>.<span class="hljs-params">getColumn</span>()</span>, get<span class="hljs-constructor">RawTypeConverter()</span>);
            rowConverter = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StreamRowConverter(<span class="hljs-params">rowType</span>)</span>;
        }
        builder.set<span class="hljs-constructor">RowConverter(<span class="hljs-params">rowConverter</span>, <span class="hljs-params">useAbstractBaseColumn</span>)</span>;

        return create<span class="hljs-constructor">Input(<span class="hljs-params">builder</span>.<span class="hljs-params">finish</span>()</span>);
    }
    <span class="hljs-comment">//获取数据类型转换连接器，数据类型转换关系的实现</span>
    @Override
    public RawTypeConverter get<span class="hljs-constructor">RawTypeConverter()</span> {
        return StreamRawTypeConverter::apply;
    }
}
</code></pre>
<p>StreamColumnConverter 继承 AbstractRowConverter类 是数据类型转换的具体实现，其中的方法参看源码。</p>
<p>接下来从作业执行角度阐述上述类之间的执行关系。</p>
<ol>
<li><p>com.dtstack.chunjun.Main 入口类，通过判断启动参数来决定启动何种作业。</p>
<p><img src="/chunjun/doc/contribute/image-20220614143347037.png" alt="image-20220614143347037"></p>
</li>
<li><p>解析参数生成SyncConf对象，配置执行环境。</p>
</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220614144650798.png" alt="image-20220614144650798"></p>
<ol start="3">
<li>.将上面解析生成的SyncConf，然后通过反射加载具体的插件调用createSource方法生成DataStream</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220614145127874.png" alt="image-20220614145127874"></p>
<ol start="4">
<li>createSource方法中会构建inputformat对象，然后调用createInput方法，将inputformat对象封装至DtInputFormatSourceFunction中。</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220614145839069.png" alt="image-20220614145839069"></p>
<ol start="5">
<li>DtInputFormatSourceFunction类中会调用inputformat对象中的逻辑去读取数据，inputformat中的nextRecordInternal方法读数据时，会对每条数据进行数据类型转换。</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220614150742626.png" alt="image-20220614150742626"></p>
<ol start="6">
<li><p>数据类型转换，flink自己内部有一套自己的数据类型，用来和外部系统进行交互。交互过程分为：将外部系统数据按照定义的类型读入到flink内部、将外部数据转换成flink内部类型、将内部类型进行转换写到外部系统。所以每个插件需要有一套类型转换机制来满足数据交互的需求。</p>
</li>
<li><p>将外部数据转换成flink内部类，每个插件的转换方式都不同。</p>
</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220614151300210.png" alt="image-20220614151300210"></p>

              <a id="(2) writer" style='display: block; height: 35px;'></a>
              <h4>
                (2) writer
              </h4>
            <p>插件数据源读取逻辑需要继承BaseRichOutputFormat类，BaseRichOutputFormat是具体的输入数据的操作，包括open、writeRecord、close，每个插件具体操作自己的数据，OutputFormat公共内容都在BaseRichOutputFormat，不要随意修改。</p>
<p>创建StreamOutputformat类继承BaseRichOutputformat类，重写其中的必要方法。</p>
<pre><code class="language-java">public class <span class="hljs-type">StreamOutputFormat</span> extends <span class="hljs-type">BaseRichOutputFormat</span> {
    //打开资源
    @<span class="hljs-type">Override</span>
    protected <span class="hljs-type">void</span> openInternal(<span class="hljs-type">int</span> taskNumber, <span class="hljs-type">int</span> numTasks) <span class="hljs-meta">{......}</span>
    //写出单条数据
    @<span class="hljs-type">Override</span>
    protected <span class="hljs-type">void</span> writeSingleRecordInternal(<span class="hljs-type">RowData</span> rowData) throws <span class="hljs-type">WriteRecordException</span> <span class="hljs-meta">{......}</span>
    //写出多条数据
    @<span class="hljs-type">Override</span>
    protected <span class="hljs-type">void</span> writeMultipleRecordsInternal() throws <span class="hljs-type">Exception</span> <span class="hljs-meta">{......}</span>
    //关闭资源
    @<span class="hljs-type">Override</span>
    protected <span class="hljs-type">void</span> closeInternal() <span class="hljs-meta">{......}</span>
}
</code></pre>
<p>StreamOutputFormat类是通过StreamOutputFormatBuilder构建的</p>
<pre><code class="language-java">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamOutputFormatBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseRichOutputFormatBuilder</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-type">StreamOutputFormat</span> format;

    public <span class="hljs-type">StreamOutputFormatBuilder</span>() {
        <span class="hljs-keyword">super</span>.format = format = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamOutputFormat</span>();
    }
    <span class="hljs-comment">//检查Outputformat配置</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">protected</span> void checkFormat() {......}
}
</code></pre>
<p>创建StreamSinkFactory类继承SinkFactory类</p>
<pre><code class="language-java">public <span class="hljs-keyword">class</span> StreamSinkFactory extends SinkFactory {

    <span class="hljs-keyword">private</span> final StreamConf streamConf;

    public <span class="hljs-constructor">StreamSinkFactory(SyncConf <span class="hljs-params">config</span>)</span> {......}
    
    <span class="hljs-comment">//构建数据输出流对象</span>
    @Override
    public DataStreamSink&lt;RowData&gt; create<span class="hljs-constructor">Sink(DataStream&lt;RowData&gt; <span class="hljs-params">dataSet</span>)</span> {
        StreamOutputFormatBuilder builder = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StreamOutputFormatBuilder()</span>;
        builder.set<span class="hljs-constructor">StreamConf(<span class="hljs-params">streamConf</span>)</span>;
        AbstractRowConverter converter;
        <span class="hljs-keyword">if</span> (useAbstractBaseColumn) {
            converter = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StreamColumnConverter(<span class="hljs-params">streamConf</span>)</span>;
        } <span class="hljs-keyword">else</span> {
            final RowType rowType =
                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TableUtil</span>.</span></span>create<span class="hljs-constructor">RowType(<span class="hljs-params">streamConf</span>.<span class="hljs-params">getColumn</span>()</span>, get<span class="hljs-constructor">RawTypeConverter()</span>);
            converter = <span class="hljs-keyword">new</span> <span class="hljs-constructor">StreamRowConverter(<span class="hljs-params">rowType</span>)</span>;
        }

        builder.set<span class="hljs-constructor">RowConverter(<span class="hljs-params">converter</span>, <span class="hljs-params">useAbstractBaseColumn</span>)</span>;
        return create<span class="hljs-constructor">Output(<span class="hljs-params">dataSet</span>, <span class="hljs-params">builder</span>.<span class="hljs-params">finish</span>()</span>);
    }
    <span class="hljs-comment">//获取数据类型转换连接器，数据类型转换关系的实现</span>
    @Override
    public RawTypeConverter get<span class="hljs-constructor">RawTypeConverter()</span> {
        return StreamRawTypeConverter::apply;
    }
}
</code></pre>
<p>接下来从作业执行角度阐述上述类之间的执行关系，在阐述reader插件执行步骤第三步时，通过反射加载具体的插件调用createSource方法生成DataStream，同理，在生成DataStream后，writer插件也是通过反射加载调用createSink方法生成DataStreamSink的。</p>
<p><img src="/chunjun/doc/contribute/image-20220616102414067.png" alt="image-20220616102414067"></p>
<ol>
<li>createSink方法中会构建outputformat对象，然后调用createoutput方法，将outputformat对象封装至DtOutputFormatSinkFunction中。</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220616102856402.png" alt="image-20220616102856402"></p>
<ol start="2">
<li>DtOutputFormatSinkFunction类中会调用outputformat对象中的逻辑去写入数据，outputformat中的writeSingleRecordInternal方法写入数据时，会对每条数据进行数据类型转换。</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220616103241458.png" alt="image-20220616103241458"></p>

              <a id="三. sql插件" style='display: block; height: 35px;'></a>
              <h3>
                三. sql插件
              </h3>
            <p><strong>Flink SQL Connetor 详细设计文档参见</strong><a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-95%3A+New+TableSource+and+TableSink+interfaces">FLIP-95</a></p>
<p>Flink SQL Connector的架构简图如下所示:</p>
<img src="/chunjun/doc/contribute/195230-11f4ee6bc7e788c7.webp" alt="195230-11f4ee6bc7e788c7.webp" style="zoom:67%;" />

<p>动态表一直都是Flink SQL流批一体化的重要概念，也是上述架构中Planning阶段的核心。而自定义Connector的主要工作就是实现基于动态表的Source/Sink，还包括上游产生它的工厂，以及下游在Runtime阶段实际执行Source/Sink逻辑的RuntimeProvider。</p>
<p>DynamicTableFactory需要具备以下功能：</p>
<ul>
<li>定义与校验建表时传入的各项参数；</li>
<li>获取表的元数据；</li>
<li>定义读写数据时的编码/解码格式（非必需）；</li>
<li>创建可用的DynamicTable[Source/Sink]实例。</li>
</ul>
<p>DynamicTableSourceFactory：源表工厂，里面包含从source来的表(如：源表kafka)，从lookup来的表(如：维表mysql)</p>
<p>DynamicTableSinkFactory：结果表工厂，里面包含从sink来的表(如：结果表mysql)</p>
<p>DynamicTableSource：生成需要读取数据的RichSourceFunction(面向流)\RichInputFormat(面向批，也可以用于流)，实现ScanTableSource即可得到。生成需要读取数据的TableFunction(全量)\AsyncTableFunction(lru)，实现LookupTableSource即可。并被包装成Provider。</p>
<p>DynamicTableSink：生成需要写出数据的RichSinkFunction(面向流)\RichOutputFormat(面向批，也可以用于流)。并被包装成Provider。</p>
<p>如果一个插件需要source端包含源表和维表,则实现ScanTableSource和LookupTableSource接口</p>
<p>如果一个插件需要sink端，则实现DynamicTableSink接口</p>
<p>实现了DynamicTable[Source/Sink]Factory接口的工厂类如下所示。</p>
<pre><code class="language-java"><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">StreamDynamicTableFactory</span> <span class="hljs-selector-tag">implements</span> <span class="hljs-selector-tag">DynamicTableSourceFactory</span>, <span class="hljs-selector-tag">DynamicTableSinkFactory</span> {
  <span class="hljs-comment">//创建DynamicTableSource</span>
  <span class="hljs-variable">@Override</span>
  public DynamicTableSource <span class="hljs-built_in">createDynamicTableSource</span>(Context context) { }
  <span class="hljs-comment">//创建DynamicTableSink</span>
  <span class="hljs-variable">@Override</span>
  public DynamicTableSink <span class="hljs-built_in">createDynamicTableSink</span>(Context context) { }
  <span class="hljs-comment">//connector唯一标识符</span>
  <span class="hljs-variable">@Override</span>
  public String <span class="hljs-built_in">factoryIdentifier</span>() { }
  <span class="hljs-comment">//必选参数设置</span>
  <span class="hljs-variable">@Override</span>
  public Set&lt;ConfigOption&lt;?&gt;&gt; <span class="hljs-built_in">requiredOptions</span>() { }
  <span class="hljs-comment">//可选参数设置</span>
  <span class="hljs-variable">@Override</span>
  public Set&lt;ConfigOption&lt;?&gt;&gt; <span class="hljs-built_in">optionalOptions</span>() { }
}
</code></pre>
<ol>
<li>根据Connector特性是否只用到source、sink，实现对应的接口，这里以stream为例：既可以作为源表、又可以作为结果表，所以实现如下：</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220614152751238.png" alt="image-20220614152751238"></p>
<ol start="2">
<li>实现createDynamicTableSource方法用来创建DynamicTableSource(ScanTableSource)，在创建之前，我们可以利用内置的TableFactoryHelper工具类来校验传入的参数，当然也可以自己编写校验逻辑。另外，通过关联的上下文对象还能获取到表的元数据。</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220614152928836.png" alt="image-20220614152928836"></p>
<ol start="3">
<li><p>创建StreamDynamicTableSource类，目前stream实现了ScanTableSource，实现getScanRuntimeProvider方法，用来创建DtInputFormatSourceFunction(并创建StreamInputFormat包含在DtInputFormatSourceFunction中)</p>
<p>DtInputFormatSourceFunction：是所有InputFormat的包装类，里面实现类2pc等功能，不要随意修改。</p>
</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220614153545215.png" alt="image-20220614153545215"></p>
<ol start="4">
<li><p>最后创建StreamInputFormat，用来对数据的操作包括(open、writeRecord、close方法)，公共的内容已经抽取到了BaseRichInputFormat中，是所有OutputFormat的公共类，不要随意修改。</p>
</li>
<li><p>sink类似。</p>
</li>
<li><p>插件也可按需求实现LookupTableSource类，以jdbc插件为例，实现getLookupRuntimeProvider方法，创建JdbcLruTableFunction/JdbcAllTableFunction，</p>
<pre><code class="language-tex">维表，支持全量和异步方式
<span class="hljs-section">全量缓存:将维表数据全部加载到内存中，建议数据量大不使用。</span>
<span class="hljs-section">异步缓存:使用异步方式查询数据，并将查询到的数据使用lru缓存到内存中，建议数据量大使用。</span>
</code></pre>
</li>
</ol>
<p><img src="/chunjun/doc/contribute/image-20220616112115980.png" alt="images"></p>
<ol start="7">
<li><p>JdbcLruTableFunction继承AbstractLruTableFunction，重写其必要方法，JdbcAllTableFunction继承AbstractAllTableFunction，具体逻辑实现参考源码。</p>
</li>
<li><p>Flink SQL采用SPI机制来发现与加载表工厂类。所以最后不要忘了classpath的META-INF/services目录下创建一个名为<code>org.apache.flink.table.factories.Factory</code>的文件，并写入我们自定义的工厂类的全限定名，如：com.dtstack.chunjun.connector.stream.table.StreamDynamicTableFactory</p>
</li>
</ol>

              <a id="四. 插件打包" style='display: block; height: 35px;'></a>
              <h3>
                四. 插件打包
              </h3>
            <p>进入项目根目录，使用maven打包，有关打包配置请参考其他插件的pom文件。</p>
<pre><code class="language-sh">mvn clean <span class="hljs-keyword">package</span> <span class="hljs-title">-DskipTests</span>
</code></pre>
<p>打包之前注意代码格式，在项目根目录执行以下命令格式化代码。</p>
<pre><code class="language-shell"><span class="hljs-keyword">mvn</span> spotless:apply
</code></pre>
<p>打包结束后，项目根目录下会产生chunjun-dist目录，如果没意外的话，您开发的插件会在connetor目录下，之后就可以提交开发平台测试啦！</p>
</article></div><cite class="mantine-o8skp2 mantine-Blockquote-cite">– 如何自定义插件</cite></div></div></blockquote></div></div><div class="text-center"><a class="mantine-UnstyledButton-root mantine-Button-root capitalize mantine-18rat7q" type="button" data-button="true" href="#top"><div class="mantine-3xbgk5 mantine-Button-inner"><span class="mantine-qo1k2 mantine-Button-label">回 到 顶 部</span></div></a></div></div><section class="text-white pt-[100px] pb-[20px] z-[1000]" style="background-color:hsl(196.89999999999998, 48.8%, 20.6%)"><div class="text-white flex flex-col md:flex-row justify-center"><div class=" w-full flex justify-center items-center bg-block bg-contain bg-center bg-no-repeat"><a class="mantine-Paper-root mantine-Card-root bg-transparent mantine-mp7k2v"><div class="mantine-Card-cardSection flex justify-center items-center mantine-i2fjw4" padding="md" data-first="true"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27140%27%20height=%27140%27/%3e"/></span><img alt="二维码" srcSet="https://dtstack.github.io/chunjun/assets/img/dt.jpg?auto=format&amp;fit=max&amp;w=256 1x, https://dtstack.github.io/chunjun/assets/img/dt.jpg?auto=format&amp;fit=max&amp;w=384 2x" src="https://dtstack.github.io/chunjun/assets/img/dt.jpg?auto=format&amp;fit=max&amp;w=384" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/></span></div><div class="mantine-Text-root text-center text-gray-300 mantine-cybdp5">联系我们</div><div class="mantine-Text-root mantine-1jt6jod">在这里你可以获取到最新的技术及产品知识</div></a></div><div class="h-full bg-block2 bg-no-repeat bg-center bg-contain w-full flex justify-center items-center"><div class="flex md:space-x-12 space-x-6"><div class="text-center"><h3 class="mb-5 text-[20px]">文档</h3><ul class="flex flex-col space-y-2 text-[13px] text-gray-300"><a href="/chunjun/documents/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">快速开始</a></ul></div><div class="text-center"><h3 class="mb-5 text-[20px]">社区</h3><ul class="flex flex-col space-y-2 text-[13px] text-gray-300"><a href="https://github.com/DTStack/chunjun/issues">Issue Tracker</a><a href="https://github.com/DTStack/chunjun/pulls">Pull Requests</a><a href="https://github.com/DTStack/chunjun/discussions">Discussions</a></ul></div><div class="text-center"><h3 class="mb-5 text-[20px]">更多</h3><ul class="flex flex-col text-[13px] space-y-2 text-gray-300"><a href="/chunjun">博客</a><a href="https://github.com/DTStack/chunjun">Github</a></ul></div></div></div></div><div class="pt-[20px] text-white text-base flex justify-center items-center text-center">Apache LICENSE 2.0 Licensed, Copyright 2018-2022 Chunjun All Rights Reserved</div></section></main></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"PR":{"content":"\n              \u003ca id=\"如何提交一个优秀的pr\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch1\u003e\n                如何提交一个优秀的pr\n              \u003c/h1\u003e\n            \u003cp\u003e在github上提交pr是参与ChunJun开源项目的一个重要途径，小伙伴们在使用中的一些功能上feature或者bug都可以向社区提交pr贡献代码，也可以根据已有的issue提供自己的解决方案。下面给大家带来提交一个优秀PR的步骤。\u003c/p\u003e\n\n              \u003ca id=\"第一步：fork chunjun到自己的github仓库\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch2\u003e\n                第一步：fork chunjun到自己的github仓库\n              \u003c/h2\u003e\n            \u003cp\u003e\u003cimg src=\"/chunjun/doc/pr/pr1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e点击fork后就可以在自己仓库中看到以你名字命名的chunjun项目了：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/pr/pr2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\n              \u003ca id=\"第二步：clone chunjun到本地IDE\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch2\u003e\n                第二步：clone chunjun到本地IDE\n              \u003c/h2\u003e\n            \u003cp\u003e\u003cimg src=\"/chunjun/doc/pr/pr3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\n              \u003ca id=\"第三步：将DTStack/chunjun设置为本地仓库的远程分支upstream\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch2\u003e\n                第三步：将DTStack/chunjun设置为本地仓库的远程分支upstream\n              \u003c/h2\u003e\n            \u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ cd chunjun\n\u003cspan class=\"hljs-comment\"\u003e# add upstream\u003c/span\u003e\n$ git remote add upstream https:\u003cspan class=\"hljs-regexp\"\u003e//gi\u003c/span\u003ethub.com\u003cspan class=\"hljs-regexp\"\u003e/DTStack/\u003c/span\u003echunjun.git\n\u003cspan class=\"hljs-comment\"\u003e# 查看远程仓库设置\u003c/span\u003e\n$ git remote -v\norigin  https:\u003cspan class=\"hljs-regexp\"\u003e//gi\u003c/span\u003ethub.com\u003cspan class=\"hljs-regexp\"\u003e/your_name/\u003c/span\u003echunjun.git (fetch)\norigin  https:\u003cspan class=\"hljs-regexp\"\u003e//gi\u003c/span\u003ethub.com\u003cspan class=\"hljs-regexp\"\u003e/your_name/\u003c/span\u003echunjun.git (push)\nupstream    https:\u003cspan class=\"hljs-regexp\"\u003e//gi\u003c/span\u003ethub.com\u003cspan class=\"hljs-regexp\"\u003e/DTStack/\u003c/span\u003echunjun.git (fetch)\nupstream    https:\u003cspan class=\"hljs-regexp\"\u003e//gi\u003c/span\u003ethub.com\u003cspan class=\"hljs-regexp\"\u003e/DTStack/\u003c/span\u003echunjun.git (push)\n\u003c/code\u003e\u003c/pre\u003e\n\n              \u003ca id=\"第四步：提交代码\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch2\u003e\n                第四步：提交代码\n              \u003c/h2\u003e\n            \u003cp\u003e任何一个提交都要基于最新的分支\n\u003cstrong\u003e切换分支\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e\u003cspan class=\"hljs-comment\"\u003e# Fetch branches from upstream.\u003c/span\u003e\n\u003cspan class=\"hljs-variable\"\u003e$ \u003c/span\u003egit remote update upstream -p\n\u003cspan class=\"hljs-comment\"\u003e# Checkout a new branch.\u003c/span\u003e\n\u003cspan class=\"hljs-variable\"\u003e$ \u003c/span\u003egit checkout -b branch_name\n\u003cspan class=\"hljs-comment\"\u003e# Pull latest code into your own branch.\u003c/span\u003e\n\u003cspan class=\"hljs-variable\"\u003e$ \u003c/span\u003egit pull upstream \u003cspan class=\"hljs-symbol\"\u003emaster:\u003c/span\u003ebranch_name\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e本地修改代码后，提交commit\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecommit message 规范：\n[commit_type-#issue-id] [module] message\u003c/li\u003e\n\u003cli\u003ecommit_type:\u003cul\u003e\n\u003cli\u003efeat：表示是一个新功能（feature)\u003c/li\u003e\n\u003cli\u003ehotfix：hotfix，修补bug\u003c/li\u003e\n\u003cli\u003edocs：改动、增加文档\u003c/li\u003e\n\u003cli\u003eopt：修改代码风格及opt imports这些，不改动原有执行的代码\u003c/li\u003e\n\u003cli\u003etest：增加测试\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eeg:[hotfix-#12345][mysql] Fix mysql time type loses precision.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注意：\n（1）commit 需遵循规范，给维护者减少维护成本及工作量，对于不符合规范的commit，我们不与合并；\n（2）对于解决同一个Issue的PR，只能存在一个commit message，如果出现多次提交的message，我们希望你能将commit message \u0026#39;squash\u0026#39; 成一个；\n（3）message 尽量保持清晰简洁，但是也千万不要因为过度追求简洁导致描述不清楚，如果有必要，我们也不介意message过长，前提是，能够把解决方案、修复内容描述清楚；\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 提交commit前先进行代码格式化\u003c/span\u003e\n\u003cspan class=\"hljs-variable\"\u003e$ \u003c/span\u003emvn \u003cspan class=\"hljs-symbol\"\u003espotless:\u003c/span\u003eapply\n\u003cspan class=\"hljs-variable\"\u003e$ \u003c/span\u003egit commit -a -m \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026lt;you_commit_message\u0026gt;\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003erebase远程分支\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这一步很重要，因为我们仓库中的chunjun代码很有可能已经落后于社区，所以在 push commit前需要rebase，保证当前commit是基于社区最新的代码，很多小伙伴没有这一步导致提交的pr当中包含了其他人的commit\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e\u003cspan class=\"hljs-meta prompt_\"\u003e$ \u003c/span\u003e\u003cspan class=\"language-bash\"\u003egit fetch upstream\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e$ \u003c/span\u003e\u003cspan class=\"language-bash\"\u003egit rebase upstream/branch_name\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e*rebase后有可能出现代码冲突，一般是由于多人编辑同一个文件引起的，只需要根据提示打开冲突文件对冲突部分进行修改，将提示的冲突文件的冲突都解决后，执行\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e\u003cspan class=\"hljs-meta prompt_\"\u003e$ \u003c/span\u003e\u003cspan class=\"language-bash\"\u003egit add .\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e$ \u003c/span\u003e\u003cspan class=\"language-bash\"\u003egit rebase --\u003cspan class=\"hljs-built_in\"\u003econtinue\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e依此往复，直至屏幕出现类似rebase successful字样即可\u003c/p\u003e\n\u003cp\u003e*rebase之后代码可能无法正常推送，需要\u003ccode\u003egit push -f\u003c/code\u003e 强制推送，强制推送是一个有风险的操作，操作前请仔细检查以避免出现无关代码被强制覆盖的问题\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003epush到github仓库\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ git \u003cspan class=\"hljs-built_in\"\u003epush\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eorigin\u003c/span\u003e branch_name\n\u003c/code\u003e\u003c/pre\u003e\n\n              \u003ca id=\"第五步：提交pr\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch2\u003e\n                第五步：提交pr\n              \u003c/h2\u003e\n            \u003cp\u003e以笔者修复kafka写入过程中出现空指针问题为例，经过步骤四笔者已经把代码提交至笔者自己仓库的master分支\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/pr/pr4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e进入chunjun仓库页面，点击Pull Request\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/pr/pr5.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/pr/pr6.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e选择head仓库和base仓库以及相应的分支\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/pr/pr7.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e填写pr信息，pr信息应该尽量概括清楚问题的前因后果，如果存在对应issue要附加issue地址，保证问题是可追溯的\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/pr/pr8.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/pr/pr9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003ePR提交成功后需要一段时间代码review，可以耐心等待一下项目维护者review后合入，或者在PR评论区艾特相关人员。\u003c/p\u003e\n","toc":[{"text":"如何提交一个优秀的pr","level":1,"id":"19398324-bc91-49cf-8609-47a5563b9fa7"},{"text":"第一步：fork chunjun到自己的github仓库","level":2,"id":"ca846599-cdaf-4c0f-96a4-2b0a6ce08013"},{"text":"第二步：clone chunjun到本地IDE","level":2,"id":"9ee33811-03a9-4afd-b90b-3b99232ea8a4"},{"text":"第三步：将DTStack/chunjun设置为本地仓库的远程分支upstream","level":2,"id":"a39c47df-6f97-44f5-aa77-5145209b26d1"},{"text":"第四步：提交代码","level":2,"id":"409bd181-3d9d-4993-befc-a4a13594942a"},{"text":"第五步：提交pr","level":2,"id":"4869ce91-6c0d-440e-8a66-aec140d5e73f"}]},"plugin":{"content":"\n              \u003ca id=\"如何自定义插件\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch2\u003e\n                如何自定义插件\n              \u003c/h2\u003e\n            \u003cp\u003e本文面向ChunJun插件开发人员，尝试通过一个开发者的角度尽可能全面地阐述一个ChunJun插件所经历的过程，同时消除开发者的困惑，快速上手插件开发。\u003c/p\u003e\n\u003cp\u003e从数据流的角度来看ChunJun，可以理解为不同数据源的数据流通过对应的ChunJun插件处理，变成符合ChunJun数据规范的数据流；脏数据的处理可以理解为脏水流通过污水处理厂，变成符合标准，可以使用的水流，而对不能处理的水流收集起来。\u003c/p\u003e\n\u003cp\u003e插件开发不需要关注任务具体如何调度，只需要关注关键问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e数据源本身读写数据的正确性；\u003c/li\u003e\n\u003cli\u003e如何合理且正确地使用框架；\u003c/li\u003e\n\u003cli\u003e配置文件的规范，每个插件都应有对应的配置文件；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e每个插件应当有以下目录：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003econf：存放插件配置类的包。\u003c/li\u003e\n\u003cli\u003econverter：存放插件数据类型转换规则类的包。\u003c/li\u003e\n\u003cli\u003esource：存放插件数据源读取逻辑有关类的包。\u003c/li\u003e\n\u003cli\u003esink：存放插件数据源写入逻辑有关类的包。\u003c/li\u003e\n\u003cli\u003etable：存放插件数据源sql模式有关类的包。\u003c/li\u003e\n\u003cli\u003eutil：存放插件工具类的包，chunjun已经封装了一些常用工具类在chunjun-core模块中，如果还需编写插件工具类的请放在该插件目录中的util包。\u003c/li\u003e\n\u003c/ol\u003e\n\n              \u003ca id=\"一. Debug调试\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch3\u003e\n                一. Debug调试\n              \u003c/h3\u003e\n            \n              \u003ca id=\"（1）本地调试\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch4\u003e\n                （1）本地调试\n              \u003c/h4\u003e\n            \u003cp\u003e在chunjun-local-test模块中，官方已经写好了本地测试的LocalTest类，只需更改脚本文件路径，在代码处打上断点即可调试。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614171917692.png\" alt=\"image-20220614171917692\"\u003e\u003c/p\u003e\n\n              \u003ca id=\"（2）远程调试\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch4\u003e\n                （2）远程调试\n              \u003c/h4\u003e\n            \u003cp\u003e如果需要远程调试，那么需要在 flink-conf.yaml 中增加 Flink 的远程调试配置，然后在 idea 中配置”JVM Remote“，在代码块中打断点（这种方法还能调试 Flink 本身的代码）\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003eenv\u003cspan class=\"hljs-selector-class\"\u003e.java\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.opts\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.jobmanager\u003c/span\u003e: -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\u003cspan class=\"hljs-number\"\u003e5005\u003c/span\u003e \n\nenv\u003cspan class=\"hljs-selector-class\"\u003e.java\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.opts\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.taskmanager\u003c/span\u003e: -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\u003cspan class=\"hljs-number\"\u003e5006\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只需要修改标记的这两个地方，如果是 HA 集群，需要根据日志修改\u003cstrong\u003e怎么看日志，怎么修改，自行查资料\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614172338108.png\" alt=\"image-20220614172338108\"\u003e\u003c/p\u003e\n\u003cp\u003e至此，任务 idea 调试流程就这些内容。\u003c/p\u003e\n\n              \u003ca id=\"二. sync(json)插件\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch3\u003e\n                二. sync(json)插件\n              \u003c/h3\u003e\n            \u003cp\u003e以Stream插件为例：\u003c/p\u003e\n\n              \u003ca id=\"(1) reader\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch4\u003e\n                (1) reader\n              \u003c/h4\u003e\n            \u003cp\u003e插件数据源读取逻辑需要继承BaseRichInputFormat类，BaseRichInputFormat是具体的输入数据的操作，包括open、nextRecord、close，每个插件具体操作自己的数据，InputFormat公共内容都在BaseRichInputFormat，不要随意修改。\u003c/p\u003e\n\u003cp\u003e创建StreamInputFormat类继承BaseRichInputFormat类，重写其中的必要方法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e\u003cspan class=\"hljs-selector-tag\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eStreamInputFormat\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eBaseRichInputFormat\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e//创建数据分片\u003c/span\u003e\n    \u003cspan class=\"hljs-variable\"\u003e@Override\u003c/span\u003e\n    public InputSplit[] \u003cspan class=\"hljs-built_in\"\u003ecreateInputSplitsInternal\u003c/span\u003e(int minNumSplits) {......}\n    \u003cspan class=\"hljs-comment\"\u003e//打开数据连接\u003c/span\u003e\n    \u003cspan class=\"hljs-variable\"\u003e@Override\u003c/span\u003e\n    public void \u003cspan class=\"hljs-built_in\"\u003eopenInternal\u003c/span\u003e(InputSplit inputSplit) {......}\n    \u003cspan class=\"hljs-comment\"\u003e//读取一条数据\u003c/span\u003e\n     \u003cspan class=\"hljs-variable\"\u003e@Override\u003c/span\u003e\n    public RowData \u003cspan class=\"hljs-built_in\"\u003enextRecordInternal\u003c/span\u003e(RowData rowData) throws ReadRecordException {......}\n    \u003cspan class=\"hljs-comment\"\u003e//判断数据是否读取完毕\u003c/span\u003e\n    \u003cspan class=\"hljs-variable\"\u003e@Override\u003c/span\u003e\n    public boolean \u003cspan class=\"hljs-built_in\"\u003ereachedEnd\u003c/span\u003e() {......}\n    \u003cspan class=\"hljs-comment\"\u003e//关闭数据连接\u003c/span\u003e\n    \u003cspan class=\"hljs-variable\"\u003e@Override\u003c/span\u003e\n    protected void \u003cspan class=\"hljs-built_in\"\u003ecloseInternal\u003c/span\u003e() {......}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStreamInputFormat类是通过StreamInputFormatBuilder类构建的。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStreamInputFormatBuilder\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eBaseRichInputFormatBuilder\u0026lt;StreamInputFormat\u0026gt;\u003c/span\u003e  \u003c/span\u003e{\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eStreamInputFormat\u003c/span\u003e format;\n\n    public \u003cspan class=\"hljs-type\"\u003eStreamInputFormatBuilder\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.format = format = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eStreamInputFormat\u003c/span\u003e();\n    }\n    \u003cspan class=\"hljs-comment\"\u003e//检查inputformat配置\u003c/span\u003e\n    \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e void checkFormat() {......}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建StreamSourceFactory继承SourceFactory类\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e StreamSourceFactory extends SourceFactory {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e final StreamConf streamConf;\n\n    public \u003cspan class=\"hljs-constructor\"\u003eStreamSourceFactory(SyncConf \u003cspan class=\"hljs-params\"\u003econfig\u003c/span\u003e, StreamExecutionEnvironment \u003cspan class=\"hljs-params\"\u003eenv\u003c/span\u003e)\u003c/span\u003e {......}\n    \n    \u003cspan class=\"hljs-comment\"\u003e//构建数据流读取对象\u003c/span\u003e\n    @Override\n    public DataStream\u0026lt;RowData\u0026gt; create\u003cspan class=\"hljs-constructor\"\u003eSource()\u003c/span\u003e {\n        StreamInputFormatBuilder builder = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-constructor\"\u003eStreamInputFormatBuilder()\u003c/span\u003e;\n        builder.set\u003cspan class=\"hljs-constructor\"\u003eStreamConf(\u003cspan class=\"hljs-params\"\u003estreamConf\u003c/span\u003e)\u003c/span\u003e;\n        AbstractRowConverter rowConverter;\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (useAbstractBaseColumn) {\n            rowConverter = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-constructor\"\u003eStreamColumnConverter(\u003cspan class=\"hljs-params\"\u003estreamConf\u003c/span\u003e)\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            check\u003cspan class=\"hljs-constructor\"\u003eConstant(\u003cspan class=\"hljs-params\"\u003estreamConf\u003c/span\u003e)\u003c/span\u003e;\n            final RowType rowType =\n                    \u003cspan class=\"hljs-module-access\"\u003e\u003cspan class=\"hljs-module\"\u003e\u003cspan class=\"hljs-identifier\"\u003eTableUtil\u003c/span\u003e.\u003c/span\u003e\u003c/span\u003ecreate\u003cspan class=\"hljs-constructor\"\u003eRowType(\u003cspan class=\"hljs-params\"\u003estreamConf\u003c/span\u003e.\u003cspan class=\"hljs-params\"\u003egetColumn\u003c/span\u003e()\u003c/span\u003e, get\u003cspan class=\"hljs-constructor\"\u003eRawTypeConverter()\u003c/span\u003e);\n            rowConverter = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-constructor\"\u003eStreamRowConverter(\u003cspan class=\"hljs-params\"\u003erowType\u003c/span\u003e)\u003c/span\u003e;\n        }\n        builder.set\u003cspan class=\"hljs-constructor\"\u003eRowConverter(\u003cspan class=\"hljs-params\"\u003erowConverter\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003euseAbstractBaseColumn\u003c/span\u003e)\u003c/span\u003e;\n\n        return create\u003cspan class=\"hljs-constructor\"\u003eInput(\u003cspan class=\"hljs-params\"\u003ebuilder\u003c/span\u003e.\u003cspan class=\"hljs-params\"\u003efinish\u003c/span\u003e()\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-comment\"\u003e//获取数据类型转换连接器，数据类型转换关系的实现\u003c/span\u003e\n    @Override\n    public RawTypeConverter get\u003cspan class=\"hljs-constructor\"\u003eRawTypeConverter()\u003c/span\u003e {\n        return StreamRawTypeConverter::apply;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStreamColumnConverter 继承 AbstractRowConverter类 是数据类型转换的具体实现，其中的方法参看源码。\u003c/p\u003e\n\u003cp\u003e接下来从作业执行角度阐述上述类之间的执行关系。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003ecom.dtstack.chunjun.Main 入口类，通过判断启动参数来决定启动何种作业。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614143347037.png\" alt=\"image-20220614143347037\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e解析参数生成SyncConf对象，配置执行环境。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614144650798.png\" alt=\"image-20220614144650798\"\u003e\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e.将上面解析生成的SyncConf，然后通过反射加载具体的插件调用createSource方法生成DataStream\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614145127874.png\" alt=\"image-20220614145127874\"\u003e\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003ecreateSource方法中会构建inputformat对象，然后调用createInput方法，将inputformat对象封装至DtInputFormatSourceFunction中。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614145839069.png\" alt=\"image-20220614145839069\"\u003e\u003c/p\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003eDtInputFormatSourceFunction类中会调用inputformat对象中的逻辑去读取数据，inputformat中的nextRecordInternal方法读数据时，会对每条数据进行数据类型转换。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614150742626.png\" alt=\"image-20220614150742626\"\u003e\u003c/p\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e\u003cp\u003e数据类型转换，flink自己内部有一套自己的数据类型，用来和外部系统进行交互。交互过程分为：将外部系统数据按照定义的类型读入到flink内部、将外部数据转换成flink内部类型、将内部类型进行转换写到外部系统。所以每个插件需要有一套类型转换机制来满足数据交互的需求。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e将外部数据转换成flink内部类，每个插件的转换方式都不同。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614151300210.png\" alt=\"image-20220614151300210\"\u003e\u003c/p\u003e\n\n              \u003ca id=\"(2) writer\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch4\u003e\n                (2) writer\n              \u003c/h4\u003e\n            \u003cp\u003e插件数据源读取逻辑需要继承BaseRichOutputFormat类，BaseRichOutputFormat是具体的输入数据的操作，包括open、writeRecord、close，每个插件具体操作自己的数据，OutputFormat公共内容都在BaseRichOutputFormat，不要随意修改。\u003c/p\u003e\n\u003cp\u003e创建StreamOutputformat类继承BaseRichOutputformat类，重写其中的必要方法。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class \u003cspan class=\"hljs-type\"\u003eStreamOutputFormat\u003c/span\u003e extends \u003cspan class=\"hljs-type\"\u003eBaseRichOutputFormat\u003c/span\u003e {\n    //打开资源\n    @\u003cspan class=\"hljs-type\"\u003eOverride\u003c/span\u003e\n    protected \u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e openInternal(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e taskNumber, \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e numTasks) \u003cspan class=\"hljs-meta\"\u003e{......}\u003c/span\u003e\n    //写出单条数据\n    @\u003cspan class=\"hljs-type\"\u003eOverride\u003c/span\u003e\n    protected \u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e writeSingleRecordInternal(\u003cspan class=\"hljs-type\"\u003eRowData\u003c/span\u003e rowData) throws \u003cspan class=\"hljs-type\"\u003eWriteRecordException\u003c/span\u003e \u003cspan class=\"hljs-meta\"\u003e{......}\u003c/span\u003e\n    //写出多条数据\n    @\u003cspan class=\"hljs-type\"\u003eOverride\u003c/span\u003e\n    protected \u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e writeMultipleRecordsInternal() throws \u003cspan class=\"hljs-type\"\u003eException\u003c/span\u003e \u003cspan class=\"hljs-meta\"\u003e{......}\u003c/span\u003e\n    //关闭资源\n    @\u003cspan class=\"hljs-type\"\u003eOverride\u003c/span\u003e\n    protected \u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e closeInternal() \u003cspan class=\"hljs-meta\"\u003e{......}\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStreamOutputFormat类是通过StreamOutputFormatBuilder构建的\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic \u003cspan class=\"hljs-class\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eStreamOutputFormatBuilder\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eBaseRichOutputFormatBuilder\u003c/span\u003e \u003c/span\u003e{\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eStreamOutputFormat\u003c/span\u003e format;\n\n    public \u003cspan class=\"hljs-type\"\u003eStreamOutputFormatBuilder\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.format = format = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eStreamOutputFormat\u003c/span\u003e();\n    }\n    \u003cspan class=\"hljs-comment\"\u003e//检查Outputformat配置\u003c/span\u003e\n    \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eprotected\u003c/span\u003e void checkFormat() {......}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e创建StreamSinkFactory类继承SinkFactory类\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e StreamSinkFactory extends SinkFactory {\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e final StreamConf streamConf;\n\n    public \u003cspan class=\"hljs-constructor\"\u003eStreamSinkFactory(SyncConf \u003cspan class=\"hljs-params\"\u003econfig\u003c/span\u003e)\u003c/span\u003e {......}\n    \n    \u003cspan class=\"hljs-comment\"\u003e//构建数据输出流对象\u003c/span\u003e\n    @Override\n    public DataStreamSink\u0026lt;RowData\u0026gt; create\u003cspan class=\"hljs-constructor\"\u003eSink(DataStream\u0026lt;RowData\u0026gt; \u003cspan class=\"hljs-params\"\u003edataSet\u003c/span\u003e)\u003c/span\u003e {\n        StreamOutputFormatBuilder builder = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-constructor\"\u003eStreamOutputFormatBuilder()\u003c/span\u003e;\n        builder.set\u003cspan class=\"hljs-constructor\"\u003eStreamConf(\u003cspan class=\"hljs-params\"\u003estreamConf\u003c/span\u003e)\u003c/span\u003e;\n        AbstractRowConverter converter;\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (useAbstractBaseColumn) {\n            converter = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-constructor\"\u003eStreamColumnConverter(\u003cspan class=\"hljs-params\"\u003estreamConf\u003c/span\u003e)\u003c/span\u003e;\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            final RowType rowType =\n                    \u003cspan class=\"hljs-module-access\"\u003e\u003cspan class=\"hljs-module\"\u003e\u003cspan class=\"hljs-identifier\"\u003eTableUtil\u003c/span\u003e.\u003c/span\u003e\u003c/span\u003ecreate\u003cspan class=\"hljs-constructor\"\u003eRowType(\u003cspan class=\"hljs-params\"\u003estreamConf\u003c/span\u003e.\u003cspan class=\"hljs-params\"\u003egetColumn\u003c/span\u003e()\u003c/span\u003e, get\u003cspan class=\"hljs-constructor\"\u003eRawTypeConverter()\u003c/span\u003e);\n            converter = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-constructor\"\u003eStreamRowConverter(\u003cspan class=\"hljs-params\"\u003erowType\u003c/span\u003e)\u003c/span\u003e;\n        }\n\n        builder.set\u003cspan class=\"hljs-constructor\"\u003eRowConverter(\u003cspan class=\"hljs-params\"\u003econverter\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003euseAbstractBaseColumn\u003c/span\u003e)\u003c/span\u003e;\n        return create\u003cspan class=\"hljs-constructor\"\u003eOutput(\u003cspan class=\"hljs-params\"\u003edataSet\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003ebuilder\u003c/span\u003e.\u003cspan class=\"hljs-params\"\u003efinish\u003c/span\u003e()\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-comment\"\u003e//获取数据类型转换连接器，数据类型转换关系的实现\u003c/span\u003e\n    @Override\n    public RawTypeConverter get\u003cspan class=\"hljs-constructor\"\u003eRawTypeConverter()\u003c/span\u003e {\n        return StreamRawTypeConverter::apply;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e接下来从作业执行角度阐述上述类之间的执行关系，在阐述reader插件执行步骤第三步时，通过反射加载具体的插件调用createSource方法生成DataStream，同理，在生成DataStream后，writer插件也是通过反射加载调用createSink方法生成DataStreamSink的。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220616102414067.png\" alt=\"image-20220616102414067\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ecreateSink方法中会构建outputformat对象，然后调用createoutput方法，将outputformat对象封装至DtOutputFormatSinkFunction中。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220616102856402.png\" alt=\"image-20220616102856402\"\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eDtOutputFormatSinkFunction类中会调用outputformat对象中的逻辑去写入数据，outputformat中的writeSingleRecordInternal方法写入数据时，会对每条数据进行数据类型转换。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220616103241458.png\" alt=\"image-20220616103241458\"\u003e\u003c/p\u003e\n\n              \u003ca id=\"三. sql插件\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch3\u003e\n                三. sql插件\n              \u003c/h3\u003e\n            \u003cp\u003e\u003cstrong\u003eFlink SQL Connetor 详细设计文档参见\u003c/strong\u003e\u003ca href=\"https://cwiki.apache.org/confluence/display/FLINK/FLIP-95%3A+New+TableSource+and+TableSink+interfaces\"\u003eFLIP-95\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eFlink SQL Connector的架构简图如下所示:\u003c/p\u003e\n\u003cimg src=\"/chunjun/doc/contribute/195230-11f4ee6bc7e788c7.webp\" alt=\"195230-11f4ee6bc7e788c7.webp\" style=\"zoom:67%;\" /\u003e\n\n\u003cp\u003e动态表一直都是Flink SQL流批一体化的重要概念，也是上述架构中Planning阶段的核心。而自定义Connector的主要工作就是实现基于动态表的Source/Sink，还包括上游产生它的工厂，以及下游在Runtime阶段实际执行Source/Sink逻辑的RuntimeProvider。\u003c/p\u003e\n\u003cp\u003eDynamicTableFactory需要具备以下功能：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e定义与校验建表时传入的各项参数；\u003c/li\u003e\n\u003cli\u003e获取表的元数据；\u003c/li\u003e\n\u003cli\u003e定义读写数据时的编码/解码格式（非必需）；\u003c/li\u003e\n\u003cli\u003e创建可用的DynamicTable[Source/Sink]实例。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDynamicTableSourceFactory：源表工厂，里面包含从source来的表(如：源表kafka)，从lookup来的表(如：维表mysql)\u003c/p\u003e\n\u003cp\u003eDynamicTableSinkFactory：结果表工厂，里面包含从sink来的表(如：结果表mysql)\u003c/p\u003e\n\u003cp\u003eDynamicTableSource：生成需要读取数据的RichSourceFunction(面向流)\\RichInputFormat(面向批，也可以用于流)，实现ScanTableSource即可得到。生成需要读取数据的TableFunction(全量)\\AsyncTableFunction(lru)，实现LookupTableSource即可。并被包装成Provider。\u003c/p\u003e\n\u003cp\u003eDynamicTableSink：生成需要写出数据的RichSinkFunction(面向流)\\RichOutputFormat(面向批，也可以用于流)。并被包装成Provider。\u003c/p\u003e\n\u003cp\u003e如果一个插件需要source端包含源表和维表,则实现ScanTableSource和LookupTableSource接口\u003c/p\u003e\n\u003cp\u003e如果一个插件需要sink端，则实现DynamicTableSink接口\u003c/p\u003e\n\u003cp\u003e实现了DynamicTable[Source/Sink]Factory接口的工厂类如下所示。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e\u003cspan class=\"hljs-selector-tag\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eStreamDynamicTableFactory\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eDynamicTableSourceFactory\u003c/span\u003e, \u003cspan class=\"hljs-selector-tag\"\u003eDynamicTableSinkFactory\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e//创建DynamicTableSource\u003c/span\u003e\n  \u003cspan class=\"hljs-variable\"\u003e@Override\u003c/span\u003e\n  public DynamicTableSource \u003cspan class=\"hljs-built_in\"\u003ecreateDynamicTableSource\u003c/span\u003e(Context context) { }\n  \u003cspan class=\"hljs-comment\"\u003e//创建DynamicTableSink\u003c/span\u003e\n  \u003cspan class=\"hljs-variable\"\u003e@Override\u003c/span\u003e\n  public DynamicTableSink \u003cspan class=\"hljs-built_in\"\u003ecreateDynamicTableSink\u003c/span\u003e(Context context) { }\n  \u003cspan class=\"hljs-comment\"\u003e//connector唯一标识符\u003c/span\u003e\n  \u003cspan class=\"hljs-variable\"\u003e@Override\u003c/span\u003e\n  public String \u003cspan class=\"hljs-built_in\"\u003efactoryIdentifier\u003c/span\u003e() { }\n  \u003cspan class=\"hljs-comment\"\u003e//必选参数设置\u003c/span\u003e\n  \u003cspan class=\"hljs-variable\"\u003e@Override\u003c/span\u003e\n  public Set\u0026lt;ConfigOption\u0026lt;?\u0026gt;\u0026gt; \u003cspan class=\"hljs-built_in\"\u003erequiredOptions\u003c/span\u003e() { }\n  \u003cspan class=\"hljs-comment\"\u003e//可选参数设置\u003c/span\u003e\n  \u003cspan class=\"hljs-variable\"\u003e@Override\u003c/span\u003e\n  public Set\u0026lt;ConfigOption\u0026lt;?\u0026gt;\u0026gt; \u003cspan class=\"hljs-built_in\"\u003eoptionalOptions\u003c/span\u003e() { }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e根据Connector特性是否只用到source、sink，实现对应的接口，这里以stream为例：既可以作为源表、又可以作为结果表，所以实现如下：\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614152751238.png\" alt=\"image-20220614152751238\"\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e实现createDynamicTableSource方法用来创建DynamicTableSource(ScanTableSource)，在创建之前，我们可以利用内置的TableFactoryHelper工具类来校验传入的参数，当然也可以自己编写校验逻辑。另外，通过关联的上下文对象还能获取到表的元数据。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614152928836.png\" alt=\"image-20220614152928836\"\u003e\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cp\u003e创建StreamDynamicTableSource类，目前stream实现了ScanTableSource，实现getScanRuntimeProvider方法，用来创建DtInputFormatSourceFunction(并创建StreamInputFormat包含在DtInputFormatSourceFunction中)\u003c/p\u003e\n\u003cp\u003eDtInputFormatSourceFunction：是所有InputFormat的包装类，里面实现类2pc等功能，不要随意修改。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220614153545215.png\" alt=\"image-20220614153545215\"\u003e\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e\u003cp\u003e最后创建StreamInputFormat，用来对数据的操作包括(open、writeRecord、close方法)，公共的内容已经抽取到了BaseRichInputFormat中，是所有OutputFormat的公共类，不要随意修改。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003esink类似。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e插件也可按需求实现LookupTableSource类，以jdbc插件为例，实现getLookupRuntimeProvider方法，创建JdbcLruTableFunction/JdbcAllTableFunction，\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-tex\"\u003e维表，支持全量和异步方式\n\u003cspan class=\"hljs-section\"\u003e全量缓存:将维表数据全部加载到内存中，建议数据量大不使用。\u003c/span\u003e\n\u003cspan class=\"hljs-section\"\u003e异步缓存:使用异步方式查询数据，并将查询到的数据使用lru缓存到内存中，建议数据量大使用。\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg src=\"/chunjun/doc/contribute/image-20220616112115980.png\" alt=\"images\"\u003e\u003c/p\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e\u003cp\u003eJdbcLruTableFunction继承AbstractLruTableFunction，重写其必要方法，JdbcAllTableFunction继承AbstractAllTableFunction，具体逻辑实现参考源码。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eFlink SQL采用SPI机制来发现与加载表工厂类。所以最后不要忘了classpath的META-INF/services目录下创建一个名为\u003ccode\u003eorg.apache.flink.table.factories.Factory\u003c/code\u003e的文件，并写入我们自定义的工厂类的全限定名，如：com.dtstack.chunjun.connector.stream.table.StreamDynamicTableFactory\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\n              \u003ca id=\"四. 插件打包\" style='display: block; height: 35px;'\u003e\u003c/a\u003e\n              \u003ch3\u003e\n                四. 插件打包\n              \u003c/h3\u003e\n            \u003cp\u003e进入项目根目录，使用maven打包，有关打包配置请参考其他插件的pom文件。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003emvn clean \u003cspan class=\"hljs-keyword\"\u003epackage\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003e-DskipTests\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e打包之前注意代码格式，在项目根目录执行以下命令格式化代码。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e\u003cspan class=\"hljs-keyword\"\u003emvn\u003c/span\u003e spotless:apply\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e打包结束后，项目根目录下会产生chunjun-dist目录，如果没意外的话，您开发的插件会在connetor目录下，之后就可以提交开发平台测试啦！\u003c/p\u003e\n","toc":[{"text":"如何自定义插件","level":2,"id":"0f2136d9-ae45-41c1-a137-3cc8f6cc8963"},{"text":"一. Debug调试","level":3,"id":"02053292-d2b6-4e16-911b-fde4255655c8"},{"text":"（1）本地调试","level":4,"id":"3f413ff9-5ceb-432f-aa10-64246061c068"},{"text":"（2）远程调试","level":4,"id":"ae3d88dd-9140-4f19-ab39-6caa8270b7af"},{"text":"二. sync(json)插件","level":3,"id":"5d7fad82-db75-4ceb-8b47-eca94b19ade0"},{"text":"(1) reader","level":4,"id":"38f2c677-07ad-4d74-861f-5dfac23c0c9a"},{"text":"(2) writer","level":4,"id":"871322e3-57d1-45f5-b278-75e0ef490960"},{"text":"三. sql插件","level":3,"id":"9128a6e1-182b-4c03-bf8c-4a2d1649fc69"},{"text":"四. 插件打包","level":3,"id":"d48a479f-397a-4cf0-8978-1bb65ee58519"}]}},"__N_SSG":true},"page":"/faq","query":{},"buildId":"jacWqOyTtEWAregOgv7R0","assetPrefix":"/chunjun","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>