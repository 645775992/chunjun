{"pageProps":{"PR":{"content":"\n              <a id=\"如何提交一个优秀的pr\" style='display: block; height: 35px;'></a>\n              <h1>\n                如何提交一个优秀的pr\n              </h1>\n            <p>在github上提交pr是参与ChunJun开源项目的一个重要途径，小伙伴们在使用中的一些功能上feature或者bug都可以向社区提交pr贡献代码，也可以根据已有的issue提供自己的解决方案。下面给大家带来提交一个优秀PR的步骤。</p>\n\n              <a id=\"第一步：fork chunjun到自己的github仓库\" style='display: block; height: 35px;'></a>\n              <h2>\n                第一步：fork chunjun到自己的github仓库\n              </h2>\n            <p><img src=\"/chunjun/doc/pr/pr1.png\" alt=\"image\"></p>\n<p>点击fork后就可以在自己仓库中看到以你名字命名的chunjun项目了：</p>\n<p><img src=\"/chunjun/doc/pr/pr2.png\" alt=\"image\"></p>\n\n              <a id=\"第二步：clone chunjun到本地IDE\" style='display: block; height: 35px;'></a>\n              <h2>\n                第二步：clone chunjun到本地IDE\n              </h2>\n            <p><img src=\"/chunjun/doc/pr/pr3.png\" alt=\"image\"></p>\n\n              <a id=\"第三步：将DTStack/chunjun设置为本地仓库的远程分支upstream\" style='display: block; height: 35px;'></a>\n              <h2>\n                第三步：将DTStack/chunjun设置为本地仓库的远程分支upstream\n              </h2>\n            <pre><code class=\"language-shell\">$ cd chunjun\n<span class=\"hljs-comment\"># add upstream</span>\n$ git remote add upstream https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/DTStack/</span>chunjun.git\n<span class=\"hljs-comment\"># 查看远程仓库设置</span>\n$ git remote -v\norigin  https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/your_name/</span>chunjun.git (fetch)\norigin  https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/your_name/</span>chunjun.git (push)\nupstream    https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/DTStack/</span>chunjun.git (fetch)\nupstream    https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/DTStack/</span>chunjun.git (push)\n</code></pre>\n\n              <a id=\"第四步：提交代码\" style='display: block; height: 35px;'></a>\n              <h2>\n                第四步：提交代码\n              </h2>\n            <p>任何一个提交都要基于最新的分支\n<strong>切换分支</strong></p>\n<pre><code class=\"language-shell\"><span class=\"hljs-comment\"># Fetch branches from upstream.</span>\n<span class=\"hljs-variable\">$ </span>git remote update upstream -p\n<span class=\"hljs-comment\"># Checkout a new branch.</span>\n<span class=\"hljs-variable\">$ </span>git checkout -b branch_name\n<span class=\"hljs-comment\"># Pull latest code into your own branch.</span>\n<span class=\"hljs-variable\">$ </span>git pull upstream <span class=\"hljs-symbol\">master:</span>branch_name\n</code></pre>\n<p><strong>本地修改代码后，提交commit</strong></p>\n<ul>\n<li>commit message 规范：\n[commit_type-#issue-id] [module] message</li>\n<li>commit_type:<ul>\n<li>feat：表示是一个新功能（feature)</li>\n<li>hotfix：hotfix，修补bug</li>\n<li>docs：改动、增加文档</li>\n<li>opt：修改代码风格及opt imports这些，不改动原有执行的代码</li>\n<li>test：增加测试</li>\n</ul>\n</li>\n<li>eg:[hotfix-#12345][mysql] Fix mysql time type loses precision.</li>\n</ul>\n<p>注意：\n（1）commit 需遵循规范，给维护者减少维护成本及工作量，对于不符合规范的commit，我们不与合并；\n（2）对于解决同一个Issue的PR，只能存在一个commit message，如果出现多次提交的message，我们希望你能将commit message &#39;squash&#39; 成一个；\n（3）message 尽量保持清晰简洁，但是也千万不要因为过度追求简洁导致描述不清楚，如果有必要，我们也不介意message过长，前提是，能够把解决方案、修复内容描述清楚；</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-comment\"># 提交commit前先进行代码格式化</span>\n<span class=\"hljs-variable\">$ </span>mvn <span class=\"hljs-symbol\">spotless:</span>apply\n<span class=\"hljs-variable\">$ </span>git commit -a -m <span class=\"hljs-string\">&quot;&lt;you_commit_message&gt;&quot;</span>\n</code></pre>\n<p><strong>rebase远程分支</strong></p>\n<p>这一步很重要，因为我们仓库中的chunjun代码很有可能已经落后于社区，所以在 push commit前需要rebase，保证当前commit是基于社区最新的代码，很多小伙伴没有这一步导致提交的pr当中包含了其他人的commit</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git fetch upstream</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase upstream/branch_name</span>\n</code></pre>\n<p>*rebase后有可能出现代码冲突，一般是由于多人编辑同一个文件引起的，只需要根据提示打开冲突文件对冲突部分进行修改，将提示的冲突文件的冲突都解决后，执行</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git add .</span>\n<span class=\"hljs-meta prompt_\">$ </span><span class=\"language-bash\">git rebase --<span class=\"hljs-built_in\">continue</span></span>\n</code></pre>\n<p>依此往复，直至屏幕出现类似rebase successful字样即可</p>\n<p>*rebase之后代码可能无法正常推送，需要<code>git push -f</code> 强制推送，强制推送是一个有风险的操作，操作前请仔细检查以避免出现无关代码被强制覆盖的问题</p>\n<p><strong>push到github仓库</strong></p>\n<pre><code class=\"language-shell\">$ git <span class=\"hljs-built_in\">push</span> <span class=\"hljs-built_in\">origin</span> branch_name\n</code></pre>\n\n              <a id=\"第五步：提交pr\" style='display: block; height: 35px;'></a>\n              <h2>\n                第五步：提交pr\n              </h2>\n            <p>以笔者修复kafka写入过程中出现空指针问题为例，经过步骤四笔者已经把代码提交至笔者自己仓库的master分支</p>\n<p><img src=\"/chunjun/doc/pr/pr4.png\" alt=\"image\"></p>\n<p>进入chunjun仓库页面，点击Pull Request</p>\n<p><img src=\"/chunjun/doc/pr/pr5.png\" alt=\"image\"></p>\n<p><img src=\"/chunjun/doc/pr/pr6.png\" alt=\"image\"></p>\n<p>选择head仓库和base仓库以及相应的分支</p>\n<p><img src=\"/chunjun/doc/pr/pr7.png\" alt=\"image\"></p>\n<p>填写pr信息，pr信息应该尽量概括清楚问题的前因后果，如果存在对应issue要附加issue地址，保证问题是可追溯的</p>\n<p><img src=\"/chunjun/doc/pr/pr8.png\" alt=\"image\"></p>\n<p><img src=\"/chunjun/doc/pr/pr9.png\" alt=\"image\"></p>\n<p>PR提交成功后需要一段时间代码review，可以耐心等待一下项目维护者review后合入，或者在PR评论区艾特相关人员。</p>\n","toc":[{"text":"如何提交一个优秀的pr","level":1,"id":"19398324-bc91-49cf-8609-47a5563b9fa7"},{"text":"第一步：fork chunjun到自己的github仓库","level":2,"id":"ca846599-cdaf-4c0f-96a4-2b0a6ce08013"},{"text":"第二步：clone chunjun到本地IDE","level":2,"id":"9ee33811-03a9-4afd-b90b-3b99232ea8a4"},{"text":"第三步：将DTStack/chunjun设置为本地仓库的远程分支upstream","level":2,"id":"a39c47df-6f97-44f5-aa77-5145209b26d1"},{"text":"第四步：提交代码","level":2,"id":"409bd181-3d9d-4993-befc-a4a13594942a"},{"text":"第五步：提交pr","level":2,"id":"4869ce91-6c0d-440e-8a66-aec140d5e73f"}]},"plugin":{"content":"\n              <a id=\"如何自定义插件\" style='display: block; height: 35px;'></a>\n              <h2>\n                如何自定义插件\n              </h2>\n            <p>本文面向ChunJun插件开发人员，尝试通过一个开发者的角度尽可能全面地阐述一个ChunJun插件所经历的过程，同时消除开发者的困惑，快速上手插件开发。</p>\n<p>从数据流的角度来看ChunJun，可以理解为不同数据源的数据流通过对应的ChunJun插件处理，变成符合ChunJun数据规范的数据流；脏数据的处理可以理解为脏水流通过污水处理厂，变成符合标准，可以使用的水流，而对不能处理的水流收集起来。</p>\n<p>插件开发不需要关注任务具体如何调度，只需要关注关键问题：</p>\n<ol>\n<li>数据源本身读写数据的正确性；</li>\n<li>如何合理且正确地使用框架；</li>\n<li>配置文件的规范，每个插件都应有对应的配置文件；</li>\n</ol>\n<p>每个插件应当有以下目录：</p>\n<ol>\n<li>conf：存放插件配置类的包。</li>\n<li>converter：存放插件数据类型转换规则类的包。</li>\n<li>source：存放插件数据源读取逻辑有关类的包。</li>\n<li>sink：存放插件数据源写入逻辑有关类的包。</li>\n<li>table：存放插件数据源sql模式有关类的包。</li>\n<li>util：存放插件工具类的包，chunjun已经封装了一些常用工具类在chunjun-core模块中，如果还需编写插件工具类的请放在该插件目录中的util包。</li>\n</ol>\n\n              <a id=\"一. Debug调试\" style='display: block; height: 35px;'></a>\n              <h3>\n                一. Debug调试\n              </h3>\n            \n              <a id=\"（1）本地调试\" style='display: block; height: 35px;'></a>\n              <h4>\n                （1）本地调试\n              </h4>\n            <p>在chunjun-local-test模块中，官方已经写好了本地测试的LocalTest类，只需更改脚本文件路径，在代码处打上断点即可调试。</p>\n<p><img src=\"/chunjun/doc/contribute/image-20220614171917692.png\" alt=\"image-20220614171917692\"></p>\n\n              <a id=\"（2）远程调试\" style='display: block; height: 35px;'></a>\n              <h4>\n                （2）远程调试\n              </h4>\n            <p>如果需要远程调试，那么需要在 flink-conf.yaml 中增加 Flink 的远程调试配置，然后在 idea 中配置”JVM Remote“，在代码块中打断点（这种方法还能调试 Flink 本身的代码）</p>\n<pre><code class=\"language-shell\">env<span class=\"hljs-selector-class\">.java</span><span class=\"hljs-selector-class\">.opts</span><span class=\"hljs-selector-class\">.jobmanager</span>: -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=<span class=\"hljs-number\">5005</span> \n\nenv<span class=\"hljs-selector-class\">.java</span><span class=\"hljs-selector-class\">.opts</span><span class=\"hljs-selector-class\">.taskmanager</span>: -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=<span class=\"hljs-number\">5006</span>\n</code></pre>\n<p>只需要修改标记的这两个地方，如果是 HA 集群，需要根据日志修改<strong>怎么看日志，怎么修改，自行查资料</strong>。</p>\n<p><img src=\"/chunjun/doc/contribute/image-20220614172338108.png\" alt=\"image-20220614172338108\"></p>\n<p>至此，任务 idea 调试流程就这些内容。</p>\n\n              <a id=\"二. sync(json)插件\" style='display: block; height: 35px;'></a>\n              <h3>\n                二. sync(json)插件\n              </h3>\n            <p>以Stream插件为例：</p>\n\n              <a id=\"(1) reader\" style='display: block; height: 35px;'></a>\n              <h4>\n                (1) reader\n              </h4>\n            <p>插件数据源读取逻辑需要继承BaseRichInputFormat类，BaseRichInputFormat是具体的输入数据的操作，包括open、nextRecord、close，每个插件具体操作自己的数据，InputFormat公共内容都在BaseRichInputFormat，不要随意修改。</p>\n<p>创建StreamInputFormat类继承BaseRichInputFormat类，重写其中的必要方法。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-selector-tag\">public</span> <span class=\"hljs-selector-tag\">class</span> <span class=\"hljs-selector-tag\">StreamInputFormat</span> <span class=\"hljs-selector-tag\">extends</span> <span class=\"hljs-selector-tag\">BaseRichInputFormat</span> {\n    <span class=\"hljs-comment\">//创建数据分片</span>\n    <span class=\"hljs-variable\">@Override</span>\n    public InputSplit[] <span class=\"hljs-built_in\">createInputSplitsInternal</span>(int minNumSplits) {......}\n    <span class=\"hljs-comment\">//打开数据连接</span>\n    <span class=\"hljs-variable\">@Override</span>\n    public void <span class=\"hljs-built_in\">openInternal</span>(InputSplit inputSplit) {......}\n    <span class=\"hljs-comment\">//读取一条数据</span>\n     <span class=\"hljs-variable\">@Override</span>\n    public RowData <span class=\"hljs-built_in\">nextRecordInternal</span>(RowData rowData) throws ReadRecordException {......}\n    <span class=\"hljs-comment\">//判断数据是否读取完毕</span>\n    <span class=\"hljs-variable\">@Override</span>\n    public boolean <span class=\"hljs-built_in\">reachedEnd</span>() {......}\n    <span class=\"hljs-comment\">//关闭数据连接</span>\n    <span class=\"hljs-variable\">@Override</span>\n    protected void <span class=\"hljs-built_in\">closeInternal</span>() {......}\n}\n</code></pre>\n<p>StreamInputFormat类是通过StreamInputFormatBuilder类构建的。</p>\n<pre><code class=\"language-java\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StreamInputFormatBuilder</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseRichInputFormatBuilder&lt;StreamInputFormat&gt;</span>  </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">StreamInputFormat</span> format;\n\n    public <span class=\"hljs-type\">StreamInputFormatBuilder</span>() {\n        <span class=\"hljs-keyword\">super</span>.format = format = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">StreamInputFormat</span>();\n    }\n    <span class=\"hljs-comment\">//检查inputformat配置</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> void checkFormat() {......}\n}\n</code></pre>\n<p>创建StreamSourceFactory继承SourceFactory类</p>\n<pre><code class=\"language-java\">public <span class=\"hljs-keyword\">class</span> StreamSourceFactory extends SourceFactory {\n    <span class=\"hljs-keyword\">private</span> final StreamConf streamConf;\n\n    public <span class=\"hljs-constructor\">StreamSourceFactory(SyncConf <span class=\"hljs-params\">config</span>, StreamExecutionEnvironment <span class=\"hljs-params\">env</span>)</span> {......}\n    \n    <span class=\"hljs-comment\">//构建数据流读取对象</span>\n    @Override\n    public DataStream&lt;RowData&gt; create<span class=\"hljs-constructor\">Source()</span> {\n        StreamInputFormatBuilder builder = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">StreamInputFormatBuilder()</span>;\n        builder.set<span class=\"hljs-constructor\">StreamConf(<span class=\"hljs-params\">streamConf</span>)</span>;\n        AbstractRowConverter rowConverter;\n        <span class=\"hljs-keyword\">if</span> (useAbstractBaseColumn) {\n            rowConverter = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">StreamColumnConverter(<span class=\"hljs-params\">streamConf</span>)</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            check<span class=\"hljs-constructor\">Constant(<span class=\"hljs-params\">streamConf</span>)</span>;\n            final RowType rowType =\n                    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TableUtil</span>.</span></span>create<span class=\"hljs-constructor\">RowType(<span class=\"hljs-params\">streamConf</span>.<span class=\"hljs-params\">getColumn</span>()</span>, get<span class=\"hljs-constructor\">RawTypeConverter()</span>);\n            rowConverter = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">StreamRowConverter(<span class=\"hljs-params\">rowType</span>)</span>;\n        }\n        builder.set<span class=\"hljs-constructor\">RowConverter(<span class=\"hljs-params\">rowConverter</span>, <span class=\"hljs-params\">useAbstractBaseColumn</span>)</span>;\n\n        return create<span class=\"hljs-constructor\">Input(<span class=\"hljs-params\">builder</span>.<span class=\"hljs-params\">finish</span>()</span>);\n    }\n    <span class=\"hljs-comment\">//获取数据类型转换连接器，数据类型转换关系的实现</span>\n    @Override\n    public RawTypeConverter get<span class=\"hljs-constructor\">RawTypeConverter()</span> {\n        return StreamRawTypeConverter::apply;\n    }\n}\n</code></pre>\n<p>StreamColumnConverter 继承 AbstractRowConverter类 是数据类型转换的具体实现，其中的方法参看源码。</p>\n<p>接下来从作业执行角度阐述上述类之间的执行关系。</p>\n<ol>\n<li><p>com.dtstack.chunjun.Main 入口类，通过判断启动参数来决定启动何种作业。</p>\n<p><img src=\"/chunjun/doc/contribute/image-20220614143347037.png\" alt=\"image-20220614143347037\"></p>\n</li>\n<li><p>解析参数生成SyncConf对象，配置执行环境。</p>\n</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220614144650798.png\" alt=\"image-20220614144650798\"></p>\n<ol start=\"3\">\n<li>.将上面解析生成的SyncConf，然后通过反射加载具体的插件调用createSource方法生成DataStream</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220614145127874.png\" alt=\"image-20220614145127874\"></p>\n<ol start=\"4\">\n<li>createSource方法中会构建inputformat对象，然后调用createInput方法，将inputformat对象封装至DtInputFormatSourceFunction中。</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220614145839069.png\" alt=\"image-20220614145839069\"></p>\n<ol start=\"5\">\n<li>DtInputFormatSourceFunction类中会调用inputformat对象中的逻辑去读取数据，inputformat中的nextRecordInternal方法读数据时，会对每条数据进行数据类型转换。</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220614150742626.png\" alt=\"image-20220614150742626\"></p>\n<ol start=\"6\">\n<li><p>数据类型转换，flink自己内部有一套自己的数据类型，用来和外部系统进行交互。交互过程分为：将外部系统数据按照定义的类型读入到flink内部、将外部数据转换成flink内部类型、将内部类型进行转换写到外部系统。所以每个插件需要有一套类型转换机制来满足数据交互的需求。</p>\n</li>\n<li><p>将外部数据转换成flink内部类，每个插件的转换方式都不同。</p>\n</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220614151300210.png\" alt=\"image-20220614151300210\"></p>\n\n              <a id=\"(2) writer\" style='display: block; height: 35px;'></a>\n              <h4>\n                (2) writer\n              </h4>\n            <p>插件数据源读取逻辑需要继承BaseRichOutputFormat类，BaseRichOutputFormat是具体的输入数据的操作，包括open、writeRecord、close，每个插件具体操作自己的数据，OutputFormat公共内容都在BaseRichOutputFormat，不要随意修改。</p>\n<p>创建StreamOutputformat类继承BaseRichOutputformat类，重写其中的必要方法。</p>\n<pre><code class=\"language-java\">public class <span class=\"hljs-type\">StreamOutputFormat</span> extends <span class=\"hljs-type\">BaseRichOutputFormat</span> {\n    //打开资源\n    @<span class=\"hljs-type\">Override</span>\n    protected <span class=\"hljs-type\">void</span> openInternal(<span class=\"hljs-type\">int</span> taskNumber, <span class=\"hljs-type\">int</span> numTasks) <span class=\"hljs-meta\">{......}</span>\n    //写出单条数据\n    @<span class=\"hljs-type\">Override</span>\n    protected <span class=\"hljs-type\">void</span> writeSingleRecordInternal(<span class=\"hljs-type\">RowData</span> rowData) throws <span class=\"hljs-type\">WriteRecordException</span> <span class=\"hljs-meta\">{......}</span>\n    //写出多条数据\n    @<span class=\"hljs-type\">Override</span>\n    protected <span class=\"hljs-type\">void</span> writeMultipleRecordsInternal() throws <span class=\"hljs-type\">Exception</span> <span class=\"hljs-meta\">{......}</span>\n    //关闭资源\n    @<span class=\"hljs-type\">Override</span>\n    protected <span class=\"hljs-type\">void</span> closeInternal() <span class=\"hljs-meta\">{......}</span>\n}\n</code></pre>\n<p>StreamOutputFormat类是通过StreamOutputFormatBuilder构建的</p>\n<pre><code class=\"language-java\">public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StreamOutputFormatBuilder</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseRichOutputFormatBuilder</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">StreamOutputFormat</span> format;\n\n    public <span class=\"hljs-type\">StreamOutputFormatBuilder</span>() {\n        <span class=\"hljs-keyword\">super</span>.format = format = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">StreamOutputFormat</span>();\n    }\n    <span class=\"hljs-comment\">//检查Outputformat配置</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">protected</span> void checkFormat() {......}\n}\n</code></pre>\n<p>创建StreamSinkFactory类继承SinkFactory类</p>\n<pre><code class=\"language-java\">public <span class=\"hljs-keyword\">class</span> StreamSinkFactory extends SinkFactory {\n\n    <span class=\"hljs-keyword\">private</span> final StreamConf streamConf;\n\n    public <span class=\"hljs-constructor\">StreamSinkFactory(SyncConf <span class=\"hljs-params\">config</span>)</span> {......}\n    \n    <span class=\"hljs-comment\">//构建数据输出流对象</span>\n    @Override\n    public DataStreamSink&lt;RowData&gt; create<span class=\"hljs-constructor\">Sink(DataStream&lt;RowData&gt; <span class=\"hljs-params\">dataSet</span>)</span> {\n        StreamOutputFormatBuilder builder = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">StreamOutputFormatBuilder()</span>;\n        builder.set<span class=\"hljs-constructor\">StreamConf(<span class=\"hljs-params\">streamConf</span>)</span>;\n        AbstractRowConverter converter;\n        <span class=\"hljs-keyword\">if</span> (useAbstractBaseColumn) {\n            converter = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">StreamColumnConverter(<span class=\"hljs-params\">streamConf</span>)</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            final RowType rowType =\n                    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">TableUtil</span>.</span></span>create<span class=\"hljs-constructor\">RowType(<span class=\"hljs-params\">streamConf</span>.<span class=\"hljs-params\">getColumn</span>()</span>, get<span class=\"hljs-constructor\">RawTypeConverter()</span>);\n            converter = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">StreamRowConverter(<span class=\"hljs-params\">rowType</span>)</span>;\n        }\n\n        builder.set<span class=\"hljs-constructor\">RowConverter(<span class=\"hljs-params\">converter</span>, <span class=\"hljs-params\">useAbstractBaseColumn</span>)</span>;\n        return create<span class=\"hljs-constructor\">Output(<span class=\"hljs-params\">dataSet</span>, <span class=\"hljs-params\">builder</span>.<span class=\"hljs-params\">finish</span>()</span>);\n    }\n    <span class=\"hljs-comment\">//获取数据类型转换连接器，数据类型转换关系的实现</span>\n    @Override\n    public RawTypeConverter get<span class=\"hljs-constructor\">RawTypeConverter()</span> {\n        return StreamRawTypeConverter::apply;\n    }\n}\n</code></pre>\n<p>接下来从作业执行角度阐述上述类之间的执行关系，在阐述reader插件执行步骤第三步时，通过反射加载具体的插件调用createSource方法生成DataStream，同理，在生成DataStream后，writer插件也是通过反射加载调用createSink方法生成DataStreamSink的。</p>\n<p><img src=\"/chunjun/doc/contribute/image-20220616102414067.png\" alt=\"image-20220616102414067\"></p>\n<ol>\n<li>createSink方法中会构建outputformat对象，然后调用createoutput方法，将outputformat对象封装至DtOutputFormatSinkFunction中。</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220616102856402.png\" alt=\"image-20220616102856402\"></p>\n<ol start=\"2\">\n<li>DtOutputFormatSinkFunction类中会调用outputformat对象中的逻辑去写入数据，outputformat中的writeSingleRecordInternal方法写入数据时，会对每条数据进行数据类型转换。</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220616103241458.png\" alt=\"image-20220616103241458\"></p>\n\n              <a id=\"三. sql插件\" style='display: block; height: 35px;'></a>\n              <h3>\n                三. sql插件\n              </h3>\n            <p><strong>Flink SQL Connetor 详细设计文档参见</strong><a href=\"https://cwiki.apache.org/confluence/display/FLINK/FLIP-95%3A+New+TableSource+and+TableSink+interfaces\">FLIP-95</a></p>\n<p>Flink SQL Connector的架构简图如下所示:</p>\n<img src=\"/chunjun/doc/contribute/195230-11f4ee6bc7e788c7.webp\" alt=\"195230-11f4ee6bc7e788c7.webp\" style=\"zoom:67%;\" />\n\n<p>动态表一直都是Flink SQL流批一体化的重要概念，也是上述架构中Planning阶段的核心。而自定义Connector的主要工作就是实现基于动态表的Source/Sink，还包括上游产生它的工厂，以及下游在Runtime阶段实际执行Source/Sink逻辑的RuntimeProvider。</p>\n<p>DynamicTableFactory需要具备以下功能：</p>\n<ul>\n<li>定义与校验建表时传入的各项参数；</li>\n<li>获取表的元数据；</li>\n<li>定义读写数据时的编码/解码格式（非必需）；</li>\n<li>创建可用的DynamicTable[Source/Sink]实例。</li>\n</ul>\n<p>DynamicTableSourceFactory：源表工厂，里面包含从source来的表(如：源表kafka)，从lookup来的表(如：维表mysql)</p>\n<p>DynamicTableSinkFactory：结果表工厂，里面包含从sink来的表(如：结果表mysql)</p>\n<p>DynamicTableSource：生成需要读取数据的RichSourceFunction(面向流)\\RichInputFormat(面向批，也可以用于流)，实现ScanTableSource即可得到。生成需要读取数据的TableFunction(全量)\\AsyncTableFunction(lru)，实现LookupTableSource即可。并被包装成Provider。</p>\n<p>DynamicTableSink：生成需要写出数据的RichSinkFunction(面向流)\\RichOutputFormat(面向批，也可以用于流)。并被包装成Provider。</p>\n<p>如果一个插件需要source端包含源表和维表,则实现ScanTableSource和LookupTableSource接口</p>\n<p>如果一个插件需要sink端，则实现DynamicTableSink接口</p>\n<p>实现了DynamicTable[Source/Sink]Factory接口的工厂类如下所示。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-selector-tag\">public</span> <span class=\"hljs-selector-tag\">class</span> <span class=\"hljs-selector-tag\">StreamDynamicTableFactory</span> <span class=\"hljs-selector-tag\">implements</span> <span class=\"hljs-selector-tag\">DynamicTableSourceFactory</span>, <span class=\"hljs-selector-tag\">DynamicTableSinkFactory</span> {\n  <span class=\"hljs-comment\">//创建DynamicTableSource</span>\n  <span class=\"hljs-variable\">@Override</span>\n  public DynamicTableSource <span class=\"hljs-built_in\">createDynamicTableSource</span>(Context context) { }\n  <span class=\"hljs-comment\">//创建DynamicTableSink</span>\n  <span class=\"hljs-variable\">@Override</span>\n  public DynamicTableSink <span class=\"hljs-built_in\">createDynamicTableSink</span>(Context context) { }\n  <span class=\"hljs-comment\">//connector唯一标识符</span>\n  <span class=\"hljs-variable\">@Override</span>\n  public String <span class=\"hljs-built_in\">factoryIdentifier</span>() { }\n  <span class=\"hljs-comment\">//必选参数设置</span>\n  <span class=\"hljs-variable\">@Override</span>\n  public Set&lt;ConfigOption&lt;?&gt;&gt; <span class=\"hljs-built_in\">requiredOptions</span>() { }\n  <span class=\"hljs-comment\">//可选参数设置</span>\n  <span class=\"hljs-variable\">@Override</span>\n  public Set&lt;ConfigOption&lt;?&gt;&gt; <span class=\"hljs-built_in\">optionalOptions</span>() { }\n}\n</code></pre>\n<ol>\n<li>根据Connector特性是否只用到source、sink，实现对应的接口，这里以stream为例：既可以作为源表、又可以作为结果表，所以实现如下：</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220614152751238.png\" alt=\"image-20220614152751238\"></p>\n<ol start=\"2\">\n<li>实现createDynamicTableSource方法用来创建DynamicTableSource(ScanTableSource)，在创建之前，我们可以利用内置的TableFactoryHelper工具类来校验传入的参数，当然也可以自己编写校验逻辑。另外，通过关联的上下文对象还能获取到表的元数据。</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220614152928836.png\" alt=\"image-20220614152928836\"></p>\n<ol start=\"3\">\n<li><p>创建StreamDynamicTableSource类，目前stream实现了ScanTableSource，实现getScanRuntimeProvider方法，用来创建DtInputFormatSourceFunction(并创建StreamInputFormat包含在DtInputFormatSourceFunction中)</p>\n<p>DtInputFormatSourceFunction：是所有InputFormat的包装类，里面实现类2pc等功能，不要随意修改。</p>\n</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220614153545215.png\" alt=\"image-20220614153545215\"></p>\n<ol start=\"4\">\n<li><p>最后创建StreamInputFormat，用来对数据的操作包括(open、writeRecord、close方法)，公共的内容已经抽取到了BaseRichInputFormat中，是所有OutputFormat的公共类，不要随意修改。</p>\n</li>\n<li><p>sink类似。</p>\n</li>\n<li><p>插件也可按需求实现LookupTableSource类，以jdbc插件为例，实现getLookupRuntimeProvider方法，创建JdbcLruTableFunction/JdbcAllTableFunction，</p>\n<pre><code class=\"language-tex\">维表，支持全量和异步方式\n<span class=\"hljs-section\">全量缓存:将维表数据全部加载到内存中，建议数据量大不使用。</span>\n<span class=\"hljs-section\">异步缓存:使用异步方式查询数据，并将查询到的数据使用lru缓存到内存中，建议数据量大使用。</span>\n</code></pre>\n</li>\n</ol>\n<p><img src=\"/chunjun/doc/contribute/image-20220616112115980.png\" alt=\"images\"></p>\n<ol start=\"7\">\n<li><p>JdbcLruTableFunction继承AbstractLruTableFunction，重写其必要方法，JdbcAllTableFunction继承AbstractAllTableFunction，具体逻辑实现参考源码。</p>\n</li>\n<li><p>Flink SQL采用SPI机制来发现与加载表工厂类。所以最后不要忘了classpath的META-INF/services目录下创建一个名为<code>org.apache.flink.table.factories.Factory</code>的文件，并写入我们自定义的工厂类的全限定名，如：com.dtstack.chunjun.connector.stream.table.StreamDynamicTableFactory</p>\n</li>\n</ol>\n\n              <a id=\"四. 插件打包\" style='display: block; height: 35px;'></a>\n              <h3>\n                四. 插件打包\n              </h3>\n            <p>进入项目根目录，使用maven打包，有关打包配置请参考其他插件的pom文件。</p>\n<pre><code class=\"language-sh\">mvn clean <span class=\"hljs-keyword\">package</span> <span class=\"hljs-title\">-DskipTests</span>\n</code></pre>\n<p>打包之前注意代码格式，在项目根目录执行以下命令格式化代码。</p>\n<pre><code class=\"language-shell\"><span class=\"hljs-keyword\">mvn</span> spotless:apply\n</code></pre>\n<p>打包结束后，项目根目录下会产生chunjun-dist目录，如果没意外的话，您开发的插件会在connetor目录下，之后就可以提交开发平台测试啦！</p>\n","toc":[{"text":"如何自定义插件","level":2,"id":"0f2136d9-ae45-41c1-a137-3cc8f6cc8963"},{"text":"一. Debug调试","level":3,"id":"02053292-d2b6-4e16-911b-fde4255655c8"},{"text":"（1）本地调试","level":4,"id":"3f413ff9-5ceb-432f-aa10-64246061c068"},{"text":"（2）远程调试","level":4,"id":"ae3d88dd-9140-4f19-ab39-6caa8270b7af"},{"text":"二. sync(json)插件","level":3,"id":"5d7fad82-db75-4ceb-8b47-eca94b19ade0"},{"text":"(1) reader","level":4,"id":"38f2c677-07ad-4d74-861f-5dfac23c0c9a"},{"text":"(2) writer","level":4,"id":"871322e3-57d1-45f5-b278-75e0ef490960"},{"text":"三. sql插件","level":3,"id":"9128a6e1-182b-4c03-bf8c-4a2d1649fc69"},{"text":"四. 插件打包","level":3,"id":"d48a479f-397a-4cf0-8978-1bb65ee58519"}]}},"__N_SSG":true}